(()=>{var t={2455:(t,e,s)=>{"use strict";var i=s(6274),n=s(9359),a=s(1555),o=s(8238),c=s(1865),r=s(8677),h=s(8578);class l{constructor(){this.type="coin_transfer",this.destination=null,this.amount=0}static coerce(t){let{type:e,destination:s,amount:i}=t;try{if("coin_transfer"!==e)return null;let t=new l;return t.type=e,t.destination=s,t.amount=i,t}catch{return null}}isValid(){try{return"coin_transfer"===this.type&&32===(0,r.nr)(this.destination).length&&Number.isFinite(this.amount)&&this.amount>0}catch{return!1}}}class u{constructor(){this.type="nft_mint",this.nftData=null,this.nftId=null}hash(){return(0,r.ci)((0,c.J)(JSON.stringify(this.nftData)))}static coerce(t){let{type:e,nftData:s,nftId:i}=t;try{if("nft_mint"!==e)return null;let t=new u;return t.type=e,t.nftData=s,t.nftId=i,t}catch{return null}}isValid(){try{return"nft_mint"===this.type&&32===(0,r.nr)(this.nftId).length&&this.nftId===this.hash()&&null!==this.nftData&&JSON.stringify(this.nftData).length>0}catch{return!1}}}class f{constructor(){this.type="nft_transfer",this.nftId=null,this.destination=null}static coerce(t){let{type:e,nftId:s,destination:i}=t;try{if("nft_transfer"!==e)return null;let t=new f;return t.type=e,t.nftId=s,t.destination=i,t}catch{return null}}isValid(){try{return"nft_transfer"===this.type&&32===(0,r.nr)(this.nftId).length&&32===(0,r.nr)(this.destination).length}catch{return!1}}}class d{constructor(){this.source=null,this.sourceNonce=0,this.timestamp=null,this.transactionFee=0,this.txData=null,this.txId=null,this.signature=null}hash(){let t=JSON.stringify([this.source,this.sourceNonce,this.timestamp,this.transactionFee,this.txData]);return(0,r.ci)((0,c.J)(t))}static coerce(t){let{source:e,sourceNonce:s,timestamp:i,transactionFee:n,txData:a,txId:o,signature:c}=t;try{let t=new d;return t.source=e,t.sourceNonce=s,t.timestamp=new Date(i),t.transactionFee=n,t.txId=o,t.signature=c,t.txData=l.coerce(a)||u.coerce(a)||f.coerce(a),t}catch{return null}}async isValid(){try{return 32===(0,r.nr)(this.source).length&&Number.isInteger(this.sourceNonce)&&this.timestamp instanceof Date&&!isNaN(this.timestamp.getTime())&&Number.isFinite(this.transactionFee)&&this.transactionFee>=0&&this.txData.isValid()&&32===(0,r.nr)(this.txId).length&&this.hash()===this.txId&&64===(0,r.nr)(this.signature).length&&await o.T(this.signature,this.txId,this.source)}catch{return!1}}async seal(t){this.source=await t.getPubKeyHex(),this.timestamp=new Date,this.txId=this.hash(),this.signature=(0,r.ci)(await t.sign(this.txId))}}var k=(0,n.Z)("raw_hash");class g{constructor(){Object.defineProperty(this,k,{value:m}),this.prevHash="00".repeat(32),this.blockHeight=0,this.timestamp=null,this.transactions=[],this.miningReward=100,this.rewardDestination=null,this.difficulty=65536,this.nonce=0}get hash(){const t=(0,i.Z)(this,k)[k]();return(0,r.ci)((0,c.J)(t+this.nonce.toString()))}static difficultyMetric(t){return(1n<<256n)/(0,h.gO)(t)}isSealed(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:65536,e=Math.max(t,this.difficulty),s=(1n<<256n)/BigInt(e);return(0,h.gO)(this.hash)<s}tryToSeal(t){var e;let s=(1n<<256n)/BigInt(this.difficulty);this.timestamp=new Date(Math.max(null!==(e=this.timestamp)&&void 0!==e?e:Date.now(),Date.now()));const n=(0,i.Z)(this,k)[k]();for(let i=0;i<t;i++){const t=(0,r.ci)((0,c.J)(n+this.nonce.toString()));if((0,h.gO)(t)<s)return this.isSealed(this.difficulty);this.nonce++}return!1}static coerce(t){let{prevHash:e,blockHeight:s,timestamp:i,transactions:n,miningReward:a,rewardDestination:o,difficulty:c,nonce:r}=t;try{let t=new g;return t.prevHash=e,t.blockHeight=s,t.timestamp=new Date(i),t.transactions=n.map((t=>d.coerce(t))),t.miningReward=a,t.rewardDestination=o,t.difficulty=c,t.nonce=r,t}catch(h){return console.error(h),null}}async isValid(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:65536;try{return this.isSealed(t)&&32===(0,r.nr)(this.prevHash).length&&Number.isInteger(this.blockHeight)&&this.blockHeight>=0&&(this.blockHeight>0||this.prevHash==="00".repeat(32))&&this.timestamp instanceof Date&&!isNaN(this.timestamp.getTime())&&Array.isArray(this.transactions)&&await async function(t,e){for(let s of t)if(!await e(s))return!1;return!0}(this.transactions,(async t=>t instanceof d&&await t.isValid()))&&Number.isFinite(this.miningReward)&&this.miningReward>=0&&32===(0,r.nr)(this.rewardDestination).length}catch{return!1}}}function m(){const{nonce:t,...e}={...this};return(0,r.ci)((0,c.J)(JSON.stringify(e)))}class p{constructor(){this.balance=0,this.nonce=0}static coerce(t){let{balance:e,nonce:s}=t,i=new p;return i.balance=e,i.nonce=s,i}}class B{constructor(){this.owner=null}static coerce(t){let{owner:e}=t,s=new B;return s.owner=e,s}}class x{constructor(t,e,s){this.message="",this.transaction=null,this.lastBlockHash=null,this.message=t,this.transaction=e,this.lastBlockHash=s}toString(){return null!==this.lastBlockHash?"Bad Transaction in "+this.lastBlockHash.toString()+":\n"+this.message+"\n"+this.transaction.toString():"Bad Transaction:\n"+this.message+"\n"+this.transaction.toString()}}class b{constructor(t,e){this.message="",this.blockHash="",this.message=t,this.blockHash=e}toString(){return"Bad Block "+this.blockHash.toString()+":\n"+this.message}}class y extends b{constructor(t,e,s){super(t,e),this.blockTimestamp=void 0,this.blockTimestamp=new Date(s)}}class w{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:2e6;this.accounts={},this.nfts={},this.transactionFees=0,this.lastBlockHash="00".repeat(32),this.lastBlockHeight=-1,this.nextBlockDifficulty=null,this.lastBlockTimestamp=null,this.totalDifficulty=0n,this.errors=[],this.children=[],this.trackedAccount=null,this.accountLedger=[],this.nftLedger={},this.nftPayloads={},this.nextBlockDifficulty=t}static coerce(t){let{accounts:e,nfts:s,transactionFees:i,lastBlockHash:n,lastBlockHeight:a,nextBlockDifficulty:o,lastBlockTimestamp:c,totalDifficulty:r,errors:h,children:l,trackedAccount:u,accountLedger:f,nftLedger:d,nftPayloads:k}=t,g=new w;return Object.keys(e).forEach((t=>{g.accounts[t]=p.coerce(e[t])})),Object.keys(s).forEach((t=>{g.nfts[t]=B.coerce(s[t])})),g.transactionFees=i,g.lastBlockHash=n,g.lastBlockHeight=a,g.nextBlockDifficulty=o,g.lastBlockTimestamp=new Date(c),g.totalDifficulty=BigInt(r),g.errors=h.map((t=>"blockTimestamp"in t?new y(t.message,t.blockHash,t.blockTimestamp):"blockHash"in t?new b(t.message,t.blockHash):new x(t.message,t.transaction,t.lastBlockHash))),g.children=l,g.trackedAccount=u,g.accountLedger=Array.from(f),g.nftLedger=JSON.parse(JSON.stringify(d)),g.nftPayloads={...k},g}toJSON(){return{accounts:this.accounts,nfts:this.nfts,transactionFees:this.transactionFees,lastBlockHash:this.lastBlockHash,lastBlockHeight:this.lastBlockHeight,nextBlockDifficulty:this.nextBlockDifficulty,lastBlockTimestamp:this.lastBlockTimestamp,totalDifficulty:this.totalDifficulty.toString(),errors:this.errors,children:this.children,trackedAccount:this.trackedAccount,accountLedger:this.accountLedger,nftLedger:this.nftLedger,nftPayloads:this.nftPayloads}}clone(){return w.coerce(this)}tryTransaction(t){if(!(arguments.length>1&&void 0!==arguments[1]&&arguments[1])&&t.timestamp>this.lastBlockTimestamp)throw new x("Transaction timestamp is newer than block timestamp!",t,this.lastBlockHash);if(t.txData instanceof l){if(!(t.source in this.accounts))throw new x("Account tried to send coins before it existed",t,this.lastBlockHash);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new x("Incorrect nonce",t,this.lastBlockHash);if(t.txData.amount+t.transactionFee>this.accounts[t.source].balance)throw new x("Insufficient balance",t,this.lastBlockHash);let e=0;this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.txData.amount+t.transactionFee,this.trackedAccount===t.source&&(e-=t.txData.amount+t.transactionFee),this.transactionFees+=t.transactionFee,t.txData.destination in this.accounts||(this.accounts[t.txData.destination]=new p),this.accounts[t.txData.destination].balance+=t.txData.amount,this.trackedAccount===t.txData.destination&&(e+=t.txData.amount),this.trackedAccount!==t.source&&this.trackedAccount!==t.txData.destination||this.accountLedger.push({txId:t.txId,delta:e})}else if(t.txData instanceof u){if(t.txData.nftId in this.nfts)throw new x("NFT Mint attempted on already-existing NFT ID",t,this.lastBlockHash);if(t.source in this.accounts||(this.accounts[t.source]=new p),t.sourceNonce!==this.accounts[t.source].nonce+1)throw new x("Incorrect nonce for NFT Mint txFee",t,this.lastBlockHash);if(t.transactionFee>this.accounts[t.source].balance)throw new x("Insufficient balance for NFT Mint txFee",t,this.lastBlockHash);this.accounts[t.source].nonce++,t.transactionFee>0&&(this.accounts[t.source].balance-=t.transactionFee,this.transactionFees+=t.transactionFee),this.trackedAccount===t.source&&this.accountLedger.push({txId:t.txId,delta:-t.transactionFee});let e=new B;e.owner=t.source,this.nfts[t.txData.nftId]=e,this.nftLedger[t.txData.nftId]=[t.txId],this.nftPayloads[t.txData.nftId]=t.txData.nftData}else if(t.txData instanceof f){let e=t.txData.nftId;if(!(e in this.nfts))throw new x("NFT Transfer attempted on non-existent NFT ID",t,this.lastBlockHash);if(this.nfts[e].owner!==t.source)throw new x("NFT Transfer attempted by non-owner of NFT",t,this.lastBlockHash);if(!(t.source in this.accounts))throw new x("Account tried to send NFT before it existed",t,this.lastBlockHash);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new x("Incorrect nonce for NFT Transfer txFee",t,this.lastBlockHash);if(t.transactionFee>this.accounts[t.source].balance)throw new x("Insufficient balance for NFT Transfer txFee",t,this.lastBlockHash);this.accounts[t.source].nonce++,t.transactionFee>0&&(this.accounts[t.source].balance-=t.transactionFee,this.transactionFees+=t.transactionFee),this.trackedAccount===t.source?this.accountLedger.push({txId:t.txId,delta:-t.transactionFee}):this.trackedAccount===t.txData.destination&&this.accountLedger.push({txId:t.txId,delta:0}),t.txData.destination in this.accounts||(this.accounts[t.txData.destination]=new p),this.nfts[e].owner=t.txData.destination,this.nftLedger[t.txData.nftId].push(t.txId)}}applyBlock(t){const e=t.hash;let s=this.clone();s.children=[],this.children.includes(e)||this.children.push(e),t.prevHash!==this.lastBlockHash&&s.errors.push(new b("Block does not point at this state's prevHash",e)),t.blockHeight!==this.lastBlockHeight+1&&s.errors.push(new b("Block height is not lastBlockHeight + 1",e)),t.timestamp>new Date(Date.now()+5e3)&&s.errors.push(new y("Block timestamp is from the future!",e,t.timestamp)),0!==t.blockHeight&&t.timestamp<this.lastBlockTimestamp&&s.errors.push(new b("Block timestamp is not greater than last block's timestamp",e)),s.lastBlockHash=e,s.lastBlockHeight=t.blockHeight;let i=0===t.blockHeight?0:Math.max(0,t.timestamp-this.lastBlockTimestamp);if(s.lastBlockTimestamp=t.timestamp,s.totalDifficulty=this.totalDifficulty+g.difficultyMetric(s.lastBlockHash),t.difficulty<this.nextBlockDifficulty&&s.errors.push(new b("Block's target difficulty is too low",e)),t.miningReward>100&&s.errors.push(new b("Block reward is too high!",e)),0===t.blockHeight)s.nextBlockDifficulty=this.nextBlockDifficulty;else{let t=i/15e3;t=Math.min(2,t);const e=40;s.nextBlockDifficulty=Math.round(this.nextBlockDifficulty*(1+(1-t)/e))}try{t.transactions.forEach((t=>{s.tryTransaction(t)}))}catch(n){s.errors.push(n)}return t.rewardDestination in s.accounts||(s.accounts[t.rewardDestination]=new p),s.accounts[t.rewardDestination].balance+=t.miningReward+s.transactionFees,s.trackedAccount===t.rewardDestination&&s.accountLedger.push({block:e,delta:t.miningReward+s.transactionFees}),s.transactionFees=0,s.errors.length&&console.error("Errors in block "+t.blockHeight+": "+JSON.stringify(s.errors)),s}}class D{constructor(t){this._blocks={},this._anticipatedBlocks={},this._readyBlocks=[],this._bestBlock=null,this._minTxFee=0,this._txPool={},this._recentConfirmedTx={},this._txToBlocks={},this._lastMiningRoot=null,this._isCheckpoint=!1,this.minDifficulty=65536,this.genesisDifficulty=2e6,this.myAccount=null,this.txIdToReject=null,this.myAccount=t}async addBlock(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.minDifficulty;try{let i=t.hash;if(t instanceof g&&await t.isValid(e)&&!(i in this._blocks)){if(this._blocks[i]={block:t},0===t.blockHeight||t.prevHash in this._blocks&&"state"in this._blocks[t.prevHash]){if(0!==t.blockHeight){const e=this.getState(t.prevHash).errors;for(let s of e)if(s instanceof y&&s.blockTimestamp<=new Date(Date.now()+5e3)){this._readyBlocks=[s.blockHash].concat(this.getChain(t.prevHash,s.blockHash));break}}this._readyBlocks.push(i)}else t.prevHash in this._anticipatedBlocks||(this._anticipatedBlocks[t.prevHash]=[]),this._anticipatedBlocks[t.prevHash].push(i),this._readyBlocks.length&&console.error("Expected _readyBlocks to be empty but there were "+this._readyBlocks.length);for(;this._readyBlocks.length;){var s;let e=this._readyBlocks.shift(),i=this.getBlock(e);if(null!==(s=this._blocks[e])&&void 0!==s&&s.isCheckpoint){console.log("Synced up to checkpoint!"),this._isCheckpoint=!1,delete this._blocks[e].isCheckpoint;continue}if(0===i.blockHeight){const t=new w(this.genesisDifficulty);t.trackedAccount=this.myAccount,this._blocks[e].state=t.applyBlock(i)}else this._blocks[e].state=this._blocks[i.prevHash].state.applyBlock(i);this.txIdToReject&&t.transactions.find((t=>t.txId===this.txIdToReject))&&this._blocks[e].state.errors.push(new b("Block contains banned transaction!",e)),i.transactions.forEach((t=>{const s=t.txId;s in this._txToBlocks||(this._txToBlocks[s]=[]),this._txToBlocks[s].push(e)})),e in this._anticipatedBlocks&&(this._readyBlocks=this._readyBlocks.concat(this._anticipatedBlocks[e]),delete this._anticipatedBlocks[e]);let n=this.getState(e);if(0===n.errors.length){let t=this.getState(this._bestBlock);(null===t||n.totalDifficulty>t.totalDifficulty)&&(this._bestBlock=e)}}return!0}}catch(i){return console.error(i),!1}}restoreCheckpoint(t,e){const s=t.hash;this._bestBlock=s,this._blocks[s]={block:t,state:e,isCheckpoint:!0},this._isCheckpoint=!0,t.prevHash in this._anticipatedBlocks||(this._anticipatedBlocks[t.prevHash]=[]),this._anticipatedBlocks[t.prevHash].push(s)}get isCheckpoint(){return this._isCheckpoint}get bestBlockHash(){return this._bestBlock}getBlock(t){return t in this._blocks?this._blocks[t].block:null}getState(t){return t in this._blocks&&"state"in this._blocks[t]?this._blocks[t].state:null}getChain(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1/0,i=[],n=null!==t&&void 0!==t?t:this.bestBlockHash,a=this.getBlock(n);for(;n!==e&&null!==a&&i.length<s&&(i.unshift(n),0!==a.blockHeight);)n=a.prevHash,a=this.getBlock(n);return i}getCommonParent(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1/0;if(t===e)return t;for(let i=0;i<s;i++){const s=this.getBlock(t);if(!s)return null;const i=s.blockHeight,n=this.getBlock(e);if(!n)return null;const a=n.blockHeight,o=Math.min(i,a);if(i>o&&(t=this.getChain(t,null,1+i-o)[0]),a>o&&(e=this.getChain(e,null,1+a-o)[0]),t===e)return t;t=this.getBlock(t).prevHash,e=this.getBlock(e).prevHash}return null}getConfirmations(t){if(this.getCommonParent(t,this.bestBlockHash,100)===t){const e=this.getBlock(t);return this.getBlock(this.bestBlockHash).blockHeight-e.blockHeight+1}return 0}getBlocksWithTransaction(t){return t in this._txToBlocks?this._txToBlocks[t]:[]}async addTransaction(t){try{if(t instanceof d&&await t.isValid()&&t.timestamp<new Date(Date.now()+3e5)&&Date.now()-t.timestamp<3e5&&!(t.txId in this._txPool)&&!(t.txId in this._recentConfirmedTx)&&t.txId!==this.txIdToReject)return this._txPool[t.txId]=t,!0}catch(e){return console.error(e),!1}}getTxPool(){return this._txPool}setMinTxFee(t){this._minTxFee=t}makeMineableBlock(t,e){var s,i,n,a;let o=null!==(s=this.bestBlockHash)&&void 0!==s?s:"00".repeat(32);if(this._lastMiningRoot!==o){const t=this.getCommonParent(this._lastMiningRoot,o,100);let e=this.getChain(this._lastMiningRoot,t,100),s=this.getChain(o,t,100),i=e.filter(((t,e)=>!s.includes(t)));i.forEach((t=>{this.getBlock(t).transactions.forEach((t=>{this._txPool[t.txId]=t,delete this._recentConfirmedTx[t.txId]}))}));let n=s.filter(((t,s)=>!e.includes(t)));n.forEach((t=>{this.getBlock(t).transactions.forEach((t=>{t.timestamp<new Date(Date.now()+3e5)&&Date.now()-t.timestamp<3e5&&(this._recentConfirmedTx[t.txId]=t),delete this._txPool[t.txId]}))})),this._lastMiningRoot=o}let c=this.getBlock(o),r=null!==(i=this.getState(o))&&void 0!==i?i:new w(this.genesisDifficulty),h=null!==(n=null===c||void 0===c?void 0:c.blockHeight)&&void 0!==n?n:-1,l=new g;l.prevHash=o,l.blockHeight=h+1,l.difficulty=r.nextBlockDifficulty,l.miningReward=t,l.rewardDestination=e;const u=Number(null!==(a=null===c||void 0===c?void 0:c.timestamp)&&void 0!==a?a:Date.now())+1;l.timestamp=new Date(Math.max(u,Date.now()));for(const k of Object.keys(this._txPool)){const t=this._txPool[k];(t.timestamp>new Date(Date.now()+3e5)||Date.now()-t.timestamp>3e5||k===this.txIdToReject)&&delete this._txPool[t.txId]}let f=r.clone(),d=[];for(const k in this._txPool)this._txPool[k].transactionFee>=this._minTxFee&&d.push(k);for(f.lastBlockTimestamp=l.timestamp;;){let t=[];if(d.forEach((e=>{try{f.tryTransaction(this._txPool[e]),t.push(e)}catch(s){if(!(s instanceof x))throw s}})),0===t.length)break;l.transactions=l.transactions.concat(t.map((t=>this._txPool[t]))),d=d.filter(((e,s)=>!t.includes(e)))}return l}}var H=(0,n.Z)("cache");a.Jj(class{constructor(t){Object.defineProperty(this,H,{writable:!0,value:void 0}),(0,i.Z)(this,H)[H]=new D(t)}async addBlock(t){let e=g.coerce(t);return await(0,i.Z)(this,H)[H].addBlock(e)}async addBlocks(t){let e=!1;for(let s of t)e=await this.addBlock(s)||e;return e}restoreCheckpoint(t,e){(0,i.Z)(this,H)[H].restoreCheckpoint(g.coerce(t),w.coerce(e))}get isCheckpoint(){return(0,i.Z)(this,H)[H].isCheckpoint}getBlockInfo(t){return{block:(0,i.Z)(this,H)[H].getBlock(t),state:(0,i.Z)(this,H)[H].getState(t)}}getBlocks(t){return t.map(((t,e)=>(0,i.Z)(this,H)[H].getBlock(t)))}getCommonParent(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1/0;return(0,i.Z)(this,H)[H].getCommonParent(t,e,s)}getChain(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1/0;return(0,i.Z)(this,H)[H].getChain(t,e,s)}getConfirmations(t){return(0,i.Z)(this,H)[H].getConfirmations(t)}get bestBlockHash(){return(0,i.Z)(this,H)[H].bestBlockHash}async addTransaction(t){let e=d.coerce(t);return await(0,i.Z)(this,H)[H].addTransaction(e)}getBlocksWithTransaction(t){return(0,i.Z)(this,H)[H].getBlocksWithTransaction(t)}getTxPool(){return(0,i.Z)(this,H)[H].getTxPool()}setMinTxFee(t){(0,i.Z)(this,H)[H].setMinTxFee(t)}makeMineableBlock(t,e){return(0,i.Z)(this,H)[H].makeMineableBlock(t,e)}cancelTransaction(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;(0,i.Z)(this,H)[H].txIdToReject=t;const e=(0,i.Z)(this,H)[H].getBlocksWithTransaction(t);for(const n of e){const t=new b("Block contains banned transaction!",n),e=(0,i.Z)(this,H)[H].getState(n);let s=[];for(e&&(e.errors.push(t),s.push(e.children));s.length;){const e=s.shift(),n=(0,i.Z)(this,H)[H].getState(e);n&&(n.errors.push(t),s.push(n.children))}}(0,i.Z)(this,H)[H]._bestBlock=null;for(const n of Object.keys((0,i.Z)(this,H)[H]._blocks)){var s;let t=(0,i.Z)(this,H)[H].getState(n);if(0===(null===t||void 0===t||null===(s=t.errors)||void 0===s?void 0:s.length)){let e=(0,i.Z)(this,H)[H].getState((0,i.Z)(this,H)[H]._bestBlock);(null===e||t.totalDifficulty>e.totalDifficulty)&&((0,i.Z)(this,H)[H]._bestBlock=n)}}}})},7420:()=>{}},e={};function s(i){var n=e[i];if(void 0!==n)return n.exports;var a=e[i]={exports:{}};return t[i](a,a.exports,s),a.exports}s.m=t,s.x=()=>{var t=s.O(void 0,[416],(()=>s(2455)));return t=s.O(t)},(()=>{var t=[];s.O=(e,i,n,a)=>{if(!i){var o=1/0;for(l=0;l<t.length;l++){for(var[i,n,a]=t[l],c=!0,r=0;r<i.length;r++)(!1&a||o>=a)&&Object.keys(s.O).every((t=>s.O[t](i[r])))?i.splice(r--,1):(c=!1,a<o&&(o=a));if(c){t.splice(l--,1);var h=n();void 0!==h&&(e=h)}}return e}a=a||0;for(var l=t.length;l>0&&t[l-1][2]>a;l--)t[l]=t[l-1];t[l]=[i,n,a]}})(),s.d=(t,e)=>{for(var i in e)s.o(e,i)&&!s.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},s.f={},s.e=t=>Promise.all(Object.keys(s.f).reduce(((e,i)=>(s.f[i](t,e),e)),[])),s.u=t=>"static/js/"+t+".6bff7d5d.chunk.js",s.miniCssF=t=>{},s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),s.p="/",(()=>{var t={475:1};s.f.i=(e,i)=>{t[e]||importScripts(s.p+s.u(e))};var e=self.webpackChunkrealbadcoin=self.webpackChunkrealbadcoin||[],i=e.push.bind(e);e.push=e=>{var[n,a,o]=e;for(var c in a)s.o(a,c)&&(s.m[c]=a[c]);for(o&&o(s);n.length;)t[n.pop()]=1;i(e)}})(),(()=>{var t=s.x;s.x=()=>s.e(416).then(t)})();s.x()})();
//# sourceMappingURL=475.074a22bc.chunk.js.map