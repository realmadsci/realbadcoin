(()=>{var t={6713:(t,e,n)=>{"use strict";function i(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}var s=0;function a(t){return"__private_"+s+++"_"+t}var c=n(1555),r=n(8238),o=n(1865),l=n(8677);function h(t){if(t<0)throw RangeError("a should be a non-negative integer. Negative values are not supported");return t.toString(16)}function u(t){return BigInt("0x"+t)}class f{constructor(){this.type="coin_transfer",this.destination=null,this.amount=0}static coerce(t){let{type:e,destination:n,amount:i}=t;try{if("coin_transfer"!==e)return null;let t=new f;return t.type=e,t.destination=n,t.amount=i,t}catch{return null}}isValid(){try{return"coin_transfer"===this.type&&32===(0,l.nr)(this.destination).length&&Number.isFinite(this.amount)&&this.amount>0}catch{return!1}}}class d{constructor(){this.type="nft_mint",this.nftData=null,this.nftId=null}hash(){return(0,l.ci)((0,o.J)(JSON.stringify(this.nftData)))}static coerce(t){let{type:e,nftData:n,nftId:i}=t;try{if("nft_mint"!==e)return null;let t=new d;return t.type=e,t.nftData=n,t.nftId=i,t}catch{return null}}isValid(){try{return"nft_mint"===this.type&&32===(0,l.nr)(this.nftId).length&&this.nftId===this.hash()&&null!==this.nftData&&JSON.stringify(this.nftData).length>0}catch{return!1}}}class k{constructor(){this.type="nft_transfer",this.nftId=null,this.nftNonce=0,this.destination=null}static coerce(t){let{type:e,nftId:n,nftNonce:i,destination:s}=t;try{if("nft_transfer"!==e)return null;let t=new k;return t.type=e,t.nftId=n,t.nftNonce=i,t.destination=s,t}catch{return null}}isValid(){try{return"nft_transfer"===this.type&&Number.isInteger(this.nftNonce)&&32===(0,l.nr)(this.nftId).length&&32===(0,l.nr)(this.destination).length}catch{return!1}}}class p{constructor(){this.source=null,this.sourceNonce=0,this.timestamp=null,this.transactionFee=0,this.txData=null,this.txId=null,this.signature=null}hash(){let t=JSON.stringify([this.source,this.sourceNonce,this.timestamp,this.transactionFee,this.txData]);return(0,l.ci)((0,o.J)(t))}static coerce(t){let{source:e,sourceNonce:n,timestamp:i,transactionFee:s,txData:a,txId:c,signature:r}=t;try{let t=new p;return t.source=e,t.sourceNonce=n,t.timestamp=new Date(i),t.transactionFee=s,t.txId=c,t.signature=r,t.txData=f.coerce(a)||d.coerce(a)||k.coerce(a),t}catch{return null}}async isValid(){try{return 32===(0,l.nr)(this.source).length&&Number.isInteger(this.sourceNonce)&&this.timestamp instanceof Date&&!isNaN(this.timestamp.getTime())&&Number.isFinite(this.transactionFee)&&this.transactionFee>=0&&this.txData.isValid()&&32===(0,l.nr)(this.txId).length&&this.hash()===this.txId&&64===(0,l.nr)(this.signature).length&&await r.T(this.signature,this.txId,this.source)}catch{return!1}}async seal(t){this.source=await t.getPubKeyHex(),this.timestamp=new Date,this.txId=this.hash(),this.signature=(0,l.ci)(await t.sign(this.txId))}}class g{constructor(){this.prevHash="00".repeat(32),this.blockHeight=0,this.timestamp=null,this.transactions=[],this.miningReward=100,this.rewardDestination=null,this.difficulty=65536,this.nonce=0}get hash(){let t=JSON.stringify(this);return(0,l.ci)((0,o.J)(t))}static difficultyMetric(t){return(1n<<256n)/u(t)}isSealed(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:65536,e=Math.max(t,this.difficulty),n=(1n<<256n)/BigInt(e);return u(this.hash)<n}tryToSeal(t){let e=(1n<<256n)/BigInt(this.difficulty);this.timestamp=new Date;for(let n=0;n<t;n++){if(u(this.hash)<e)return this.isSealed(this.difficulty);this.nonce++}return!1}static coerce(t){let{prevHash:e,blockHeight:n,timestamp:i,transactions:s,miningReward:a,rewardDestination:c,difficulty:r,nonce:o}=t;try{let t=new g;return t.prevHash=e,t.blockHeight=n,t.timestamp=new Date(i),t.transactions=s.map((t=>p.coerce(t))),t.miningReward=a,t.rewardDestination=c,t.difficulty=r,t.nonce=o,t}catch(l){return console.error(l),null}}async isValid(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:65536;try{return this.isSealed(t)&&32===(0,l.nr)(this.prevHash).length&&Number.isInteger(this.blockHeight)&&this.blockHeight>=0&&(this.blockHeight>0||this.prevHash==="00".repeat(32))&&this.timestamp instanceof Date&&!isNaN(this.timestamp.getTime())&&Array.isArray(this.transactions)&&async function(t,e){for(let n of t)if(!await e(n))return!1;return!0}(this.transactions,(async t=>t instanceof p&&await t.isValid()))&&Number.isFinite(this.miningReward)&&this.miningReward>=0&&32===(0,l.nr)(this.rewardDestination).length}catch{return!1}}}class m{constructor(){this.balance=0,this.nonce=0}static coerce(t){let{balance:e,nonce:n}=t,i=new m;return i.balance=e,i.nonce=n,i}}class y{constructor(){this.owner=null,this.nonce=0}static coerce(t){let{owner:e,nonce:n}=t,i=new y;return i.owner=e,i.nonce=n,i}}class b{constructor(t,e){this.message="",this.transaction=null,this.message=t,this.transaction=e}toString(){return"Bad Transaction:\n"+this.message+"\n"+this.transaction.toString()}}class w{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:2e6;this.accounts={},this.nfts={},this.transactionFees=0,this.lastBlockHash="00".repeat(32),this.lastBlockHeight=-1,this.nextBlockDifficulty=null,this.lastBlockTimestamp=null,this.totalDifficulty=0n,this.nextBlockDifficulty=t}static coerce(t){let{accounts:e,nfts:n,transactionFees:i,lastBlockHash:s,lastBlockHeight:a,nextBlockDifficulty:c,lastBlockTimestamp:r,totalDifficulty:o}=t,l=new w;return Object.keys(e).forEach((t=>{l.accounts[t]=m.coerce(e[t])})),Object.keys(n).forEach((t=>{l.nfts[t]=y.coerce(n[t])})),l.transactionFees=i,l.lastBlockHash=s,l.lastBlockHeight=a,l.nextBlockDifficulty=c,l.lastBlockTimestamp=r,l.totalDifficulty=o,l}clone(){let t=Object.assign({},this);return t.totalDifficulty=h(t.totalDifficulty),t=w.coerce(JSON.parse(JSON.stringify(t))),t.totalDifficulty=u(t.totalDifficulty),t}tryTransaction(t){if(t.txData instanceof f){if(!(t.source in this.accounts))throw new b("Account tried to send coins before it existed",t);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new b("Incorrect nonce",t);if(t.txData.amount+t.transactionFee>this.accounts[t.source].balance)throw new b("Insufficient balance",t);this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.txData.amount+t.transactionFee,this.transactionFees+=t.transactionFee,t.txData.destination in this.accounts||(this.accounts[t.txData.destination]=new m),this.accounts[t.txData.destination].balance+=t.txData.amount}else if(t.txData instanceof d){if(t.txData.nftId in this.nfts)throw new b("NFT Mint attempted on already-existing NFT ID",t);if(t.transactionFee>0){if(!(t.source in this.accounts))throw new b("Account tried to pay NFT Mint txFee before it existed",t);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new b("Incorrect nonce for NFT Mint txFee",t);if(t.transactionFee>this.accounts[t.source].balance)throw new b("Insufficient balance for NFT Mint txFee",t)}t.transactionFee>0&&(this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.transactionFee,this.transactionFees+=t.transactionFee);let e=new y;e.nonce=0,e.owner=t.source,this.nfts[t.txData.nftId]=e}else if(t.txData instanceof k){let e=t.txData.nftId;if(!(e in this.nfts))throw new b("NFT Transfer attempted on non-existent NFT ID",t);if(this.nfts[e].owner!==t.source)throw new b("NFT Transfer attempted by non-owner of NFT",t);if(t.txData.nftNonce!==this.nfts[e].nonce+1)throw new b("Incorrect NFT nonce",t);if(t.transactionFee>0){if(!(t.source in this.accounts))throw new b("Account tried to pay NFT Mint txFee before it existed",t);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new b("Incorrect nonce for NFT Mint txFee",t);if(t.transactionFee>this.accounts[t.source].balance)throw new b("Insufficient balance for NFT Mint txFee",t)}t.transactionFee>0&&(this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.transactionFee,this.transactionFees+=t.transactionFee),this.nfts[e].nonce++,this.nfts[e].owner=t.txData.destination}}applyBlock(t){let e=this.clone();if(t.prevHash!==this.lastBlockHash)return null;if(t.blockHeight!==this.lastBlockHeight+1)return null;if(t.timestamp>new Date)return null;if(0!==t.blockHeight&&t.timestamp<this.lastBlockTimestamp)return null;e.lastBlockHash=t.hash,e.lastBlockHeight=t.blockHeight;let n=0===t.blockHeight?0:t.timestamp-this.lastBlockTimestamp;if(e.lastBlockTimestamp=t.timestamp,e.totalDifficulty=this.totalDifficulty+g.difficultyMetric(e.lastBlockHash),t.difficulty<this.nextBlockDifficulty)return null;if(0===t.blockHeight)e.nextBlockDifficulty=this.nextBlockDifficulty;else{let t=n/15e3;t=Math.min(2,t);const i=40;e.nextBlockDifficulty=Math.round(this.nextBlockDifficulty*(1+(1-t)/i))}try{t.transactions.forEach((t=>{e.tryTransaction(t)}))}catch(i){return console.error(i),null}return t.rewardDestination in e.accounts||(e.accounts[t.rewardDestination]=new m),e.accounts[t.rewardDestination].balance+=t.miningReward+e.transactionFees,e.transactionFees=0,e}}class B{constructor(){this._blocks={},this._anticipatedBlocks={},this._readyBlocks=[],this._bestBlock=null,this._txPool={},this._recentConfirmedTx={},this.minDifficulty=65536,this.genesisDifficulty=2e6}addBlock(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.minDifficulty;try{let i=t.hash;if(t instanceof g&&t.isValid(n)&&!(i in this._blocks)){this._blocks[i]={block:t,source:e},0===t.blockHeight||t.prevHash in this._blocks&&"state"in this._blocks[t.prevHash]?this._readyBlocks.push(i):(t.prevHash in this._anticipatedBlocks||(this._anticipatedBlocks[t.prevHash]=[]),this._anticipatedBlocks[t.prevHash].push(i),this._readyBlocks.length&&console.error("Expected _readyBlocks to be empty but there were "+this._readyBlocks.length));for(;this._readyBlocks.length;){let t=this.getBlock(this._readyBlocks.pop()),e=t.hash;0===t.blockHeight?this._blocks[e].state=new w(this.genesisDifficulty).applyBlock(t):null===this._blocks[t.prevHash].state?this._blocks[e].state=null:this._blocks[e].state=this._blocks[t.prevHash].state.applyBlock(t),e in this._anticipatedBlocks&&(this._readyBlocks=this._readyBlocks.concat(this._anticipatedBlocks[e]),delete this._anticipatedBlocks[e]);let n=this.getState(e);if(null!==n){let t=this.getState(this._bestBlock);(null===t||n.totalDifficulty>t.totalDifficulty)&&this._updateBestBlock(e)}}return!0}}catch(i){return console.error(i),!1}}_updateBestBlock(t){let e=this._bestBlock;this._bestBlock=t;let n=this.getChain(e),i=this.getChain(t);n.filter(((t,e)=>!i.includes(t))).forEach((t=>{this.getBlock(t).transactions.forEach((t=>{this._txPool[t.txId]=t,delete this._recentConfirmedTx[t.txId]}))})),i.filter(((t,e)=>!n.includes(t))).forEach((t=>{this.getBlock(t).transactions.forEach((t=>{t.timestamp<Date.now()&&Date.now()-t.timestamp<6e5&&(this._recentConfirmedTx[t.txId]=t),delete this._txPool[t.txId]}))}))}get bestBlockHash(){return this._bestBlock}getBlock(t){return t in this._blocks?this._blocks[t].block:null}getSource(t){return t in this._blocks?this._blocks[t].source:null}getState(t){return t in this._blocks&&"state"in this._blocks[t]?this._blocks[t].state:null}getChain(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=[],i=null!==t&&void 0!==t?t:this.bestBlockHash,s=this.getBlock(i);for(;i!==e&&null!==s&&(n.unshift(i),0!==s.blockHeight);)i=s.prevHash,s=this.getBlock(i);return n}async addTransaction(t){try{if(t instanceof p&&await t.isValid()&&t.timestamp<Date.now()&&Date.now()-t.timestamp<6e5&&!(t.txId in this._txPool)&&!(t.txId in this._recentConfirmedTx))return this._txPool[t.txId]=t,!0}catch(e){return console.error(e),!1}}makeMineableBlock(t,e){var n,i,s;let a=null!==(n=this.bestBlockHash)&&void 0!==n?n:"00".repeat(32),c=this.getBlock(a),r=null!==(i=this.getState(a))&&void 0!==i?i:new w(this.genesisDifficulty),o=null!==(s=null===c||void 0===c?void 0:c.blockHeight)&&void 0!==s?s:-1,l=new g;l.prevHash=a,l.blockHeight=o+1,l.difficulty=r.nextBlockDifficulty,l.miningReward=t,l.rewardDestination=e;let h=r.clone(),u=[];for(const f in this._txPool)u.push(f);for(;;){let t=[];if(u.forEach((e=>{try{h.tryTransaction(this._txPool[e]),t.push(e)}catch(n){if(!(n instanceof b))throw n}})),0===t.length)break;l.transactions=l.transactions.concat(t.map((t=>this._txPool[t]))),u=u.filter(((e,n)=>!t.includes(e)))}return l}}var x=a("cache");c.Jj(class{constructor(){Object.defineProperty(this,x,{writable:!0,value:new B})}addBlock(t,e){let n=g.coerce(t);return i(this,x)[x].addBlock(n,e)}addBlocks(t,e){return t.map(((t,n)=>this.addBlock(t,e)))}getBlockInfo(t){return{block:i(this,x)[x].getBlock(t),state:i(this,x)[x].getState(t),source:i(this,x)[x].getSource(t)}}getBlocks(t){return t.map(((t,e)=>i(this,x)[x].getBlock(t)))}getChain(t,e){return i(this,x)[x].getChain(t,e)}get bestBlockHash(){return i(this,x)[x].bestBlockHash}addTransaction(t){let e=p.coerce(t);return i(this,x)[x].addTransaction(e)}makeMineableBlock(t,e){return i(this,x)[x].makeMineableBlock(t,e)}})},7420:()=>{}},e={};function n(i){var s=e[i];if(void 0!==s)return s.exports;var a=e[i]={exports:{}};return t[i](a,a.exports,n),a.exports}n.m=t,n.x=()=>{var t=n.O(void 0,[974],(()=>n(6713)));return t=n.O(t)},(()=>{var t=[];n.O=(e,i,s,a)=>{if(!i){var c=1/0;for(h=0;h<t.length;h++){for(var[i,s,a]=t[h],r=!0,o=0;o<i.length;o++)(!1&a||c>=a)&&Object.keys(n.O).every((t=>n.O[t](i[o])))?i.splice(o--,1):(r=!1,a<c&&(c=a));if(r){t.splice(h--,1);var l=s();void 0!==l&&(e=l)}}return e}a=a||0;for(var h=t.length;h>0&&t[h-1][2]>a;h--)t[h]=t[h-1];t[h]=[i,s,a]}})(),n.d=(t,e)=>{for(var i in e)n.o(e,i)&&!n.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},n.f={},n.e=t=>Promise.all(Object.keys(n.f).reduce(((e,i)=>(n.f[i](t,e),e)),[])),n.u=t=>"static/js/"+t+".eeffc38f.chunk.js",n.miniCssF=t=>{},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.p="/",(()=>{var t={586:1};n.f.i=(e,i)=>{t[e]||importScripts(n.p+n.u(e))};var e=self.webpackChunkrealbadcoin=self.webpackChunkrealbadcoin||[],i=e.push.bind(e);e.push=e=>{var[s,a,c]=e;for(var r in a)n.o(a,r)&&(n.m[r]=a[r]);for(c&&c(n);s.length;)t[s.pop()]=1;i(e)}})(),(()=>{var t=n.x;n.x=()=>n.e(974).then(t)})();n.x()})();
//# sourceMappingURL=586.7470a212.chunk.js.map