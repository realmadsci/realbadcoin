(()=>{var t={2455:(t,e,s)=>{"use strict";var i=s(6274),n=s(9359),a=s(1555),o=s(8238),c=s(1865),r=s(8677),l=s(8578);class h{constructor(){this.type="coin_transfer",this.destination=null,this.amount=0}static coerce(t){let{type:e,destination:s,amount:i}=t;try{if("coin_transfer"!==e)return null;let t=new h;return t.type=e,t.destination=s,t.amount=i,t}catch{return null}}isValid(){try{return"coin_transfer"===this.type&&32===(0,r.nr)(this.destination).length&&Number.isFinite(this.amount)&&this.amount>0}catch{return!1}}}class u{constructor(){this.type="nft_mint",this.nftData=null,this.nftId=null}hash(){return(0,r.ci)((0,c.J)(JSON.stringify(this.nftData)))}static coerce(t){let{type:e,nftData:s,nftId:i}=t;try{if("nft_mint"!==e)return null;let t=new u;return t.type=e,t.nftData=s,t.nftId=i,t}catch{return null}}isValid(){try{return"nft_mint"===this.type&&32===(0,r.nr)(this.nftId).length&&this.nftId===this.hash()&&null!==this.nftData&&JSON.stringify(this.nftData).length>0}catch{return!1}}}class f{constructor(){this.type="nft_transfer",this.nftId=null,this.nftNonce=0,this.destination=null}static coerce(t){let{type:e,nftId:s,nftNonce:i,destination:n}=t;try{if("nft_transfer"!==e)return null;let t=new f;return t.type=e,t.nftId=s,t.nftNonce=i,t.destination=n,t}catch{return null}}isValid(){try{return"nft_transfer"===this.type&&Number.isInteger(this.nftNonce)&&32===(0,r.nr)(this.nftId).length&&32===(0,r.nr)(this.destination).length}catch{return!1}}}class k{constructor(){this.source=null,this.sourceNonce=0,this.timestamp=null,this.transactionFee=0,this.txData=null,this.txId=null,this.signature=null}hash(){let t=JSON.stringify([this.source,this.sourceNonce,this.timestamp,this.transactionFee,this.txData]);return(0,r.ci)((0,c.J)(t))}static coerce(t){let{source:e,sourceNonce:s,timestamp:i,transactionFee:n,txData:a,txId:o,signature:c}=t;try{let t=new k;return t.source=e,t.sourceNonce=s,t.timestamp=new Date(i),t.transactionFee=n,t.txId=o,t.signature=c,t.txData=h.coerce(a)||u.coerce(a)||f.coerce(a),t}catch{return null}}async isValid(){try{return 32===(0,r.nr)(this.source).length&&Number.isInteger(this.sourceNonce)&&this.timestamp instanceof Date&&!isNaN(this.timestamp.getTime())&&Number.isFinite(this.transactionFee)&&this.transactionFee>=0&&this.txData.isValid()&&32===(0,r.nr)(this.txId).length&&this.hash()===this.txId&&64===(0,r.nr)(this.signature).length&&await o.T(this.signature,this.txId,this.source)}catch{return!1}}async seal(t){this.source=await t.getPubKeyHex(),this.timestamp=new Date,this.txId=this.hash(),this.signature=(0,r.ci)(await t.sign(this.txId))}}var d=(0,n.Z)("raw_hash");class m{constructor(){Object.defineProperty(this,d,{value:g}),this.prevHash="00".repeat(32),this.blockHeight=0,this.timestamp=null,this.transactions=[],this.miningReward=100,this.rewardDestination=null,this.difficulty=65536,this.nonce=0}get hash(){const t=(0,i.Z)(this,d)[d]();return(0,r.ci)((0,c.J)(t+this.nonce.toString()))}static difficultyMetric(t){return(1n<<256n)/(0,l.gO)(t)}isSealed(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:65536,e=Math.max(t,this.difficulty),s=(1n<<256n)/BigInt(e);return(0,l.gO)(this.hash)<s}tryToSeal(t){var e;let s=(1n<<256n)/BigInt(this.difficulty);this.timestamp=new Date(Math.max(null!==(e=this.timestamp)&&void 0!==e?e:Date.now(),Date.now()));const n=(0,i.Z)(this,d)[d]();for(let i=0;i<t;i++){const t=(0,r.ci)((0,c.J)(n+this.nonce.toString()));if((0,l.gO)(t)<s)return this.isSealed(this.difficulty);this.nonce++}return!1}static coerce(t){let{prevHash:e,blockHeight:s,timestamp:i,transactions:n,miningReward:a,rewardDestination:o,difficulty:c,nonce:r}=t;try{let t=new m;return t.prevHash=e,t.blockHeight=s,t.timestamp=new Date(i),t.transactions=n.map((t=>k.coerce(t))),t.miningReward=a,t.rewardDestination=o,t.difficulty=c,t.nonce=r,t}catch(l){return console.error(l),null}}async isValid(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:65536;try{return this.isSealed(t)&&32===(0,r.nr)(this.prevHash).length&&Number.isInteger(this.blockHeight)&&this.blockHeight>=0&&(this.blockHeight>0||this.prevHash==="00".repeat(32))&&this.timestamp instanceof Date&&!isNaN(this.timestamp.getTime())&&Array.isArray(this.transactions)&&await async function(t,e){for(let s of t)if(!await e(s))return!1;return!0}(this.transactions,(async t=>t instanceof k&&await t.isValid()))&&Number.isFinite(this.miningReward)&&this.miningReward>=0&&32===(0,r.nr)(this.rewardDestination).length}catch{return!1}}}function g(){const{nonce:t,...e}={...this};return(0,r.ci)((0,c.J)(JSON.stringify(e)))}class p{constructor(){this.balance=0,this.nonce=0}static coerce(t){let{balance:e,nonce:s}=t,i=new p;return i.balance=e,i.nonce=s,i}}class B{constructor(){this.owner=null,this.nonce=0}static coerce(t){let{owner:e,nonce:s}=t,i=new B;return i.owner=e,i.nonce=s,i}}class b{constructor(t,e,s){this.message="",this.transaction=null,this.lastBlockHash=null,this.message=t,this.transaction=e,this.lastBlockHash=s}toString(){return null!==this.lastBlockHash?"Bad Transaction in "+this.lastBlockHash.toString()+":\n"+this.message+"\n"+this.transaction.toString():"Bad Transaction:\n"+this.message+"\n"+this.transaction.toString()}}class w{constructor(t,e){this.message="",this.blockHash="",this.message=t,this.blockHash=e}toString(){return"Bad Block "+this.blockHash.toString()+":\n"+this.message}}class y extends w{constructor(t,e,s){super(t,e),this.blockTimestamp=void 0,this.blockTimestamp=new Date(s)}}class H{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:2e6;this.accounts={},this.nfts={},this.transactionFees=0,this.lastBlockHash="00".repeat(32),this.lastBlockHeight=-1,this.nextBlockDifficulty=null,this.lastBlockTimestamp=null,this.totalDifficulty=0n,this.errors=[],this.nextBlockDifficulty=t}static coerce(t){let{accounts:e,nfts:s,transactionFees:i,lastBlockHash:n,lastBlockHeight:a,nextBlockDifficulty:o,lastBlockTimestamp:c,totalDifficulty:r,errors:l}=t,h=new H;return Object.keys(e).forEach((t=>{h.accounts[t]=p.coerce(e[t])})),Object.keys(s).forEach((t=>{h.nfts[t]=B.coerce(s[t])})),h.transactionFees=i,h.lastBlockHash=n,h.lastBlockHeight=a,h.nextBlockDifficulty=o,h.lastBlockTimestamp=new Date(c),h.totalDifficulty=BigInt(r),h.errors=l.map((t=>"blockTimestamp"in t?new y(t.message,t.blockHash,t.blockTimestamp):"blockHash"in t?new w(t.message,t.blockHash):new b(t.message,t.transaction,t.lastBlockHash))),h}toJSON(){return{accounts:this.accounts,nfts:this.nfts,transactionFees:this.transactionFees,lastBlockHash:this.lastBlockHash,lastBlockHeight:this.lastBlockHeight,nextBlockDifficulty:this.nextBlockDifficulty,lastBlockTimestamp:this.lastBlockTimestamp,totalDifficulty:this.totalDifficulty.toString(),errors:this.errors}}clone(){return H.coerce(this)}tryTransaction(t){if(!(arguments.length>1&&void 0!==arguments[1]&&arguments[1])&&t.timestamp>this.lastBlockTimestamp)throw new b("Transaction timestamp is newer than block timestamp!",t,this.lastBlockHash);if(t.txData instanceof h){if(!(t.source in this.accounts))throw new b("Account tried to send coins before it existed",t,this.lastBlockHash);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new b("Incorrect nonce",t,this.lastBlockHash);if(t.txData.amount+t.transactionFee>this.accounts[t.source].balance)throw new b("Insufficient balance",t,this.lastBlockHash);this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.txData.amount+t.transactionFee,this.transactionFees+=t.transactionFee,t.txData.destination in this.accounts||(this.accounts[t.txData.destination]=new p),this.accounts[t.txData.destination].balance+=t.txData.amount}else if(t.txData instanceof u){if(t.txData.nftId in this.nfts)throw new b("NFT Mint attempted on already-existing NFT ID",t,this.lastBlockHash);if(t.transactionFee>0){if(!(t.source in this.accounts))throw new b("Account tried to pay NFT Mint txFee before it existed",t,this.lastBlockHash);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new b("Incorrect nonce for NFT Mint txFee",t,this.lastBlockHash);if(t.transactionFee>this.accounts[t.source].balance)throw new b("Insufficient balance for NFT Mint txFee",t,this.lastBlockHash)}t.transactionFee>0&&(this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.transactionFee,this.transactionFees+=t.transactionFee);let e=new B;e.nonce=0,e.owner=t.source,this.nfts[t.txData.nftId]=e}else if(t.txData instanceof f){let e=t.txData.nftId;if(!(e in this.nfts))throw new b("NFT Transfer attempted on non-existent NFT ID",t,this.lastBlockHash);if(this.nfts[e].owner!==t.source)throw new b("NFT Transfer attempted by non-owner of NFT",t,this.lastBlockHash);if(t.txData.nftNonce!==this.nfts[e].nonce+1)throw new b("Incorrect NFT nonce",t,this.lastBlockHash);if(t.transactionFee>0){if(!(t.source in this.accounts))throw new b("Account tried to pay NFT Mint txFee before it existed",t,this.lastBlockHash);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new b("Incorrect nonce for NFT Mint txFee",t,this.lastBlockHash);if(t.transactionFee>this.accounts[t.source].balance)throw new b("Insufficient balance for NFT Mint txFee",t,this.lastBlockHash)}t.transactionFee>0&&(this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.transactionFee,this.transactionFees+=t.transactionFee),this.nfts[e].nonce++,this.nfts[e].owner=t.txData.destination}}applyBlock(t){let e=this.clone();t.prevHash!==this.lastBlockHash&&e.errors.push(new w("Block does not point at this state's prevHash",t.hash)),t.blockHeight!==this.lastBlockHeight+1&&e.errors.push(new w("Block height is not lastBlockHeight + 1",t.hash)),t.timestamp>new Date(Date.now()+5e3)&&e.errors.push(new y("Block timestamp is from the future!",t.hash,t.timestamp)),0!==t.blockHeight&&t.timestamp<this.lastBlockTimestamp&&e.errors.push(new w("Block timestamp is not greater than last block's timestamp",t.hash)),e.lastBlockHash=t.hash,e.lastBlockHeight=t.blockHeight;let s=0===t.blockHeight?0:Math.max(0,t.timestamp-this.lastBlockTimestamp);if(e.lastBlockTimestamp=t.timestamp,e.totalDifficulty=this.totalDifficulty+m.difficultyMetric(e.lastBlockHash),t.difficulty<this.nextBlockDifficulty&&e.errors.push(new w("Block's target difficulty is too low",t.hash)),0===t.blockHeight)e.nextBlockDifficulty=this.nextBlockDifficulty;else{let t=s/15e3;t=Math.min(2,t);const i=40;e.nextBlockDifficulty=Math.round(this.nextBlockDifficulty*(1+(1-t)/i))}try{t.transactions.forEach((t=>{e.tryTransaction(t)}))}catch(i){e.errors.push(i)}return t.rewardDestination in e.accounts||(e.accounts[t.rewardDestination]=new p),e.accounts[t.rewardDestination].balance+=t.miningReward+e.transactionFees,e.transactionFees=0,e.errors.length&&console.error("Errors in block "+t.blockHeight+": "+JSON.stringify(e.errors)),e}}class x{constructor(){this._blocks={},this._anticipatedBlocks={},this._readyBlocks=[],this._bestBlock=null,this._txPool={},this._recentConfirmedTx={},this._lastMiningRoot=null,this.minDifficulty=65536,this.genesisDifficulty=2e6}async addBlock(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.minDifficulty;try{let i=t.hash;if(t instanceof m&&await t.isValid(s)&&!(i in this._blocks)){if(this._blocks[i]={block:t,source:e},0===t.blockHeight||t.prevHash in this._blocks&&"state"in this._blocks[t.prevHash]){if(0!==t.blockHeight){const e=this.getState(t.prevHash).errors;for(let s of e)if(s instanceof y&&s.blockTimestamp<=new Date(Date.now()+5e3)){this._readyBlocks=[s.blockHash].concat(this.getChain(t.prevHash,s.blockHash));break}}this._readyBlocks.push(i)}else t.prevHash in this._anticipatedBlocks||(this._anticipatedBlocks[t.prevHash]=[]),this._anticipatedBlocks[t.prevHash].push(i),this._readyBlocks.length&&console.error("Expected _readyBlocks to be empty but there were "+this._readyBlocks.length);for(;this._readyBlocks.length;){let t=this.getBlock(this._readyBlocks.shift()),e=t.hash;0===t.blockHeight?this._blocks[e].state=new H(this.genesisDifficulty).applyBlock(t):this._blocks[e].state=this._blocks[t.prevHash].state.applyBlock(t),e in this._anticipatedBlocks&&(this._readyBlocks=this._readyBlocks.concat(this._anticipatedBlocks[e]),delete this._anticipatedBlocks[e]);let s=this.getState(e);if(0===s.errors.length){let t=this.getState(this._bestBlock);(null===t||s.totalDifficulty>t.totalDifficulty)&&(this._bestBlock=e)}}return!0}}catch(i){return console.error(i),!1}}restoreCheckpoint(t,e){this._bestBlock=t.hash,this._blocks[this._bestBlock]={block:t,state:e}}get bestBlockHash(){return this._bestBlock}getBlock(t){return t in this._blocks?this._blocks[t].block:null}getSource(t){return t in this._blocks?this._blocks[t].source:null}getState(t){return t in this._blocks&&"state"in this._blocks[t]?this._blocks[t].state:null}getChain(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=[],i=null!==t&&void 0!==t?t:this.bestBlockHash,n=this.getBlock(i);for(;i!==e&&null!==n&&(s.unshift(i),0!==n.blockHeight);)i=n.prevHash,n=this.getBlock(i);return s}async addTransaction(t){try{if(t instanceof k&&await t.isValid()&&t.timestamp<new Date(Date.now()+3e5)&&Date.now()-t.timestamp<3e5&&!(t.txId in this._txPool)&&!(t.txId in this._recentConfirmedTx))return this._txPool[t.txId]=t,!0}catch(e){return console.error(e),!1}}makeMineableBlock(t,e){var s,i,n,a;let o=null!==(s=this.bestBlockHash)&&void 0!==s?s:"00".repeat(32);if(this._lastMiningRoot!==o){let t=this.getChain(this._lastMiningRoot),e=this.getChain(o),s=t.filter(((t,s)=>!e.includes(t)));s.forEach((t=>{this.getBlock(t).transactions.forEach((t=>{this._txPool[t.txId]=t,delete this._recentConfirmedTx[t.txId]}))}));let i=e.filter(((e,s)=>!t.includes(e)));i.forEach((t=>{this.getBlock(t).transactions.forEach((t=>{t.timestamp<new Date(Date.now()+3e5)&&Date.now()-t.timestamp<3e5&&(this._recentConfirmedTx[t.txId]=t),delete this._txPool[t.txId]}))})),this._lastMiningRoot=o}let c=this.getBlock(o),r=null!==(i=this.getState(o))&&void 0!==i?i:new H(this.genesisDifficulty),l=null!==(n=null===c||void 0===c?void 0:c.blockHeight)&&void 0!==n?n:-1,h=new m;h.prevHash=o,h.blockHeight=l+1,h.difficulty=r.nextBlockDifficulty,h.miningReward=t,h.rewardDestination=e,h.timestamp=new Date(Number(null!==(a=null===c||void 0===c?void 0:c.timestamp)&&void 0!==a?a:Date.now())+1);let u=r.clone(),f=[];for(const k in this._txPool)f.push(k);for(;;){let t=[];if(f.forEach((e=>{try{u.tryTransaction(this._txPool[e]),t.push(e)}catch(s){if(!(s instanceof b))throw s}})),0===t.length)break;h.transactions=h.transactions.concat(t.map((t=>this._txPool[t]))),f=f.filter(((e,s)=>!t.includes(e)))}return h}}var D=(0,n.Z)("cache");a.Jj(class{constructor(){Object.defineProperty(this,D,{writable:!0,value:new x})}async addBlock(t,e){let s=m.coerce(t);return await(0,i.Z)(this,D)[D].addBlock(s,e)}async addBlocks(t,e){let s=!0;for(let i of t)s=await this.addBlock(i,e)||s;return s}restoreCheckpoint(t,e){(0,i.Z)(this,D)[D].restoreCheckpoint(m.coerce(t),H.coerce(e))}getBlockInfo(t){return{block:(0,i.Z)(this,D)[D].getBlock(t),state:(0,i.Z)(this,D)[D].getState(t),source:(0,i.Z)(this,D)[D].getSource(t)}}getBlocks(t){return t.map(((t,e)=>(0,i.Z)(this,D)[D].getBlock(t)))}getChain(t,e){return(0,i.Z)(this,D)[D].getChain(t,e)}get bestBlockHash(){return(0,i.Z)(this,D)[D].bestBlockHash}async addTransaction(t){let e=k.coerce(t);return await(0,i.Z)(this,D)[D].addTransaction(e)}makeMineableBlock(t,e){return(0,i.Z)(this,D)[D].makeMineableBlock(t,e)}})},7420:()=>{}},e={};function s(i){var n=e[i];if(void 0!==n)return n.exports;var a=e[i]={exports:{}};return t[i](a,a.exports,s),a.exports}s.m=t,s.x=()=>{var t=s.O(void 0,[416],(()=>s(2455)));return t=s.O(t)},(()=>{var t=[];s.O=(e,i,n,a)=>{if(!i){var o=1/0;for(h=0;h<t.length;h++){for(var[i,n,a]=t[h],c=!0,r=0;r<i.length;r++)(!1&a||o>=a)&&Object.keys(s.O).every((t=>s.O[t](i[r])))?i.splice(r--,1):(c=!1,a<o&&(o=a));if(c){t.splice(h--,1);var l=n();void 0!==l&&(e=l)}}return e}a=a||0;for(var h=t.length;h>0&&t[h-1][2]>a;h--)t[h]=t[h-1];t[h]=[i,n,a]}})(),s.d=(t,e)=>{for(var i in e)s.o(e,i)&&!s.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},s.f={},s.e=t=>Promise.all(Object.keys(s.f).reduce(((e,i)=>(s.f[i](t,e),e)),[])),s.u=t=>"static/js/"+t+".f76753dc.chunk.js",s.miniCssF=t=>{},s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),s.p="/",(()=>{var t={475:1};s.f.i=(e,i)=>{t[e]||importScripts(s.p+s.u(e))};var e=self.webpackChunkrealbadcoin=self.webpackChunkrealbadcoin||[],i=e.push.bind(e);e.push=e=>{var[n,a,o]=e;for(var c in a)s.o(a,c)&&(s.m[c]=a[c]);for(o&&o(s);n.length;)t[n.pop()]=1;i(e)}})(),(()=>{var t=s.x;s.x=()=>s.e(416).then(t)})();s.x()})();
//# sourceMappingURL=475.2da91b0d.chunk.js.map