{"version":3,"file":"static/js/475.9d061be7.chunk.js","mappings":"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","sources":["util/RealBadCoin.tsx","util/RealBadState.tsx","util/CacheWorker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["// Data strucures and accessors for the RealBadCoin crypto currency\r\n\r\nimport * as ed from '@noble/ed25519';\r\nimport { sha256 } from '@noble/hashes/sha256';\r\nimport { bytesToHex, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\r\nimport { hexToBigint } from 'bigint-conversion';\r\n\r\nexport async function asyncEvery(arr, predicate) {\r\n\tfor (let e of arr) {\r\n\t\tif (!await predicate(e)) return false;\r\n\t}\r\n\treturn true;\r\n};\r\n\r\nexport class RealBadCoinTransfer {\r\n    type = \"coin_transfer\";\r\n    destination = null; // Destination account ID (public key)\r\n    amount = 0;         // Amount of RealBadCoin to transfer (floating point number)\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        type,\r\n        destination,\r\n        amount,\r\n    }) {\r\n        try {\r\n            if (type !== \"coin_transfer\") return null;\r\n\r\n            let r = new RealBadCoinTransfer();\r\n            r.type = type;\r\n            r.destination = destination;\r\n            r.amount = amount;\r\n            return r;\r\n        } catch {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check the all fields have correct data types\r\n    isValid() {\r\n        try {\r\n            return (\r\n                this.type === \"coin_transfer\" &&\r\n\r\n                // The destination is a 32-byte hex value\r\n                (hexToBytes(this.destination).length === 32) &&\r\n\r\n                // The amount is a finite positive number\r\n                Number.isFinite(this.amount) &&\r\n                (this.amount > 0)\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// Create a new NFT. The \"source\" account is the owner of the NFT until it is transferred via a RealBadNftTransfer.\r\n// NOTE: These aren't free - like all transactions, you have to pay a miner's fee to make one!\r\nexport class RealBadNftMint {\r\n    type = \"nft_mint\";\r\n    nftData = null;     // Any data we want to \"mint\" as an NFT. Can be a string, and object, whatever...\r\n    nftId = null;       // The ID (hash) of the `nftData` object. Must a globally unique number on the block chain (so nftData must be unique).\r\n\r\n    // Compute the hash (txId) of this object\r\n    hash() {\r\n        return bytesToHex(sha256(JSON.stringify(this.nftData)));\r\n    }\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        type,\r\n        nftData,\r\n        nftId,\r\n    }) {\r\n        try {\r\n            if (type !== \"nft_mint\") return null;\r\n\r\n            let r = new RealBadNftMint();\r\n            r.type = type;\r\n            r.nftData = nftData;\r\n            r.nftId = nftId;\r\n            return r;\r\n        } catch {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check the all fields have correct data types\r\n    isValid() {\r\n        try {\r\n            return (\r\n                this.type === \"nft_mint\" &&\r\n\r\n                // The NFT ID is a 32-byte hex value and it matches the hash\r\n                (hexToBytes(this.nftId).length === 32) &&\r\n                this.nftId === this.hash() &&\r\n\r\n                // The data isn't null and can be turned into a JSON string\r\n                this.nftData !== null &&\r\n                JSON.stringify(this.nftData).length > 0\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\nexport class RealBadNftTransfer {\r\n    type = \"nft_transfer\";\r\n    nftId = null;       // The ID (hash) of the NFT. Must already be minted before it can be transferred.\r\n    destination = null; // Destination account ID (public key) for the new owner of the NFT.\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        type,\r\n        nftId,\r\n        destination,\r\n    }) {\r\n        try {\r\n            if (type !== \"nft_transfer\") return null;\r\n\r\n            let r = new RealBadNftTransfer();\r\n            r.type = type;\r\n            r.nftId = nftId;\r\n            r.destination = destination;\r\n            return r;\r\n        } catch {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check the all fields have correct data types\r\n    isValid() {\r\n        try {\r\n            return (\r\n                this.type === \"nft_transfer\" &&\r\n\r\n                // The NFT ID is a 32-byte hex value\r\n                (hexToBytes(this.nftId).length === 32) &&\r\n\r\n                // The destination account is a 32-byte hex value\r\n                (hexToBytes(this.destination).length === 32)\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// Required base fields for every transaction that occurs in the network\r\nexport class RealBadTransaction {\r\n    source = null;          // Source account ID (public key)\r\n    sourceNonce = 0;        // Source account transaction nonce. Used to ensure transactions (including transactionFees) apply IN ORDER.\r\n                            // Must be sequentially incrementing or transaction will be ignored.\r\n                            // nonce is NOT REQURIED and NOT UPDATED if no coins are spent (txFee or transfer).\r\n    timestamp = null;       // Time when the transaction is created. Miners will only propagate and process transactions during a certain time window.\r\n    transactionFee = 0;     // Fee to be paid to the miner if this transaction is accepted into a block. Miners _might_ not accept transactions without fees!\r\n    txData = null;          // The data portion of the transaction. One of the valid transaction object types must go here.\r\n    txId = null;            // Hash of `[source, timestamp, transactionFee, txData]`. This serves as the unique ID for the transaction.\r\n    signature = null;       // Signature of `txId` using the `source` account.\r\n\r\n    // Compute the hash (txId) of this object\r\n    hash() {\r\n        let tx_val = JSON.stringify([\r\n            this.source,\r\n            this.sourceNonce,\r\n            this.timestamp,\r\n            this.transactionFee,\r\n            this.txData,\r\n        ]);\r\n        return bytesToHex(sha256(tx_val));\r\n    }\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        source,\r\n        sourceNonce,\r\n        timestamp,\r\n        transactionFee,\r\n        txData,\r\n        txId,\r\n        signature,\r\n    }) {\r\n        try {\r\n            let r = new RealBadTransaction();\r\n            r.source = source;\r\n            r.sourceNonce = sourceNonce;\r\n            r.timestamp = new Date(timestamp);\r\n            r.transactionFee = transactionFee;\r\n            r.txId = txId;\r\n            r.signature = signature;\r\n\r\n            // Cute!\r\n            r.txData =\r\n                RealBadCoinTransfer.coerce(txData) ||\r\n                RealBadNftMint.coerce(txData) ||\r\n                RealBadNftTransfer.coerce(txData);\r\n\r\n            return r;\r\n        } catch {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check the signature, hash, and confirm that all fields have correct non-null data types\r\n    async isValid() {\r\n        try {\r\n            return (\r\n                // The source ID is a 32-byte hex value\r\n                (hexToBytes(this.source).length === 32) &&\r\n\r\n                // The source nonce is an integer\r\n                Number.isInteger(this.sourceNonce) &&\r\n\r\n                // The timestamp is a Date object and contains a valid value\r\n                (this.timestamp instanceof Date) &&\r\n                !isNaN(this.timestamp.getTime()) &&\r\n\r\n                // The transaction fee is a non-negative finite number\r\n                Number.isFinite(this.transactionFee) &&\r\n                (this.transactionFee >= 0) &&\r\n\r\n                // The transaction internal data is valid\r\n                this.txData.isValid() &&\r\n\r\n                // The hash is a 32-byte hex value and it matches the actual hash of this object\r\n                (hexToBytes(this.txId).length === 32) &&\r\n                (this.hash() === this.txId) &&\r\n\r\n                // The signature is a 64-byte hex value and the signature is a valid sig of the hash from the source\r\n                (hexToBytes(this.signature).length === 64) &&\r\n                await ed.verify(this.signature, this.txId, this.source)\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Seal the transaction, setting the source and timestamp and signing it with the account object provided.\r\n    // The account object needs to provide an `async getPubKeyHex()` and `async sign()` function\r\n    async seal(account) {\r\n        this.source = await account.getPubKeyHex();\r\n        this.timestamp = new Date();\r\n        this.txId = this.hash();\r\n        this.signature = bytesToHex(await account.sign(this.txId));\r\n    }\r\n}\r\n\r\nexport class RealBadBlock {\r\n    prevHash = '00'.repeat(32); // Hash of previous block. It is included in this block to form a block-chain.\r\n    blockHeight = 0;            // How far we are \"above\" the genesis block. This is previous block's height + 1.\r\n    timestamp = null;           // Time of last update to the block (prior to hash computation). This is mainly for display purposes.\r\n    transactions = [];          // List of all transactions in the block\r\n    miningReward = 100;         // Base reward claimed for mining this block\r\n    rewardDestination = null;   // Miner's destination account ID (public key) for mining reward and transaction fees.\r\n    difficulty = 256**2;        // Required difficulty for hash. Increasing this makes it harder to find a valid hash. For example, setting this to 256**N will require the top N bytes of the hash to be zeros.\r\n    nonce = 0;                  // Number that can be changed to cause block's hash to vary\r\n\r\n    #raw_hash() {\r\n        // Remove the nonce and compute the hash of everything else:\r\n        const {nonce, ...self_minus_nonce} = {...this};\r\n        return bytesToHex(sha256(JSON.stringify(self_minus_nonce)));\r\n    }\r\n\r\n    // Compute the hash of this object\r\n    // NOTE: We don't STORE the hash of the object inside the object because this\r\n    //       isn't a signed object so we can't trust the validity of any hash that\r\n    //       is TOLD to us! We have to check it ourselves!\r\n    get hash() {\r\n        const raw_hash = this.#raw_hash();\r\n\r\n        // Now concat the raw hash with the nonce and hash _that_ to get the final hash:\r\n        return bytesToHex(sha256(raw_hash + this.nonce.toString()));\r\n    }\r\n\r\n    static difficultyMetric(h) {\r\n        // The difficulty metric is proportional to how low the hash is relative to the \"zero difficulty\" level.\r\n        // The lower the hash as an integer, the bigger the difficulty.\r\n        let zeroDifficulty = 1n << 256n;\r\n        let hashAsInt = hexToBigint(h);\r\n        return zeroDifficulty / hashAsInt;\r\n    }\r\n\r\n    isSealed(minDifficulty = 256**2) {\r\n        let difficulty = Math.max(minDifficulty, this.difficulty);\r\n        let maxHash = (1n << 256n) / BigInt(difficulty);\r\n        let hashAsInt = hexToBigint(this.hash);\r\n        return hashAsInt < maxHash;\r\n    }\r\n\r\n    // Increment the nonce and keep trying to find a hash that is valid.\r\n    // Try up to num_attempts times before giving up.\r\n    tryToSeal(num_attempts) {\r\n        let maxHash = (1n << 256n) / BigInt(this.difficulty);\r\n        // If the timestamp already has a value, don't let it go BACKWARD\r\n        this.timestamp = new Date(Math.max(this.timestamp ?? Date.now(), Date.now()));\r\n\r\n        // Compute the raw hash (without the nonce) just one time!\r\n        const raw_hash = this.#raw_hash();\r\n\r\n        for (let i = 0; i < num_attempts; i++) {\r\n            // Now concat the raw hash with the nonce and hash _that_ to get the final hash:\r\n            const hash = bytesToHex(sha256(raw_hash + this.nonce.toString()));\r\n            let hashAsInt = hexToBigint(hash);\r\n            if (hashAsInt < maxHash) {\r\n                return this.isSealed(this.difficulty);\r\n            }\r\n            // We post-increment the nonce, so that repeated calls to this function don't waste any work.\r\n            this.nonce++;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        prevHash,\r\n        blockHeight,\r\n        timestamp,\r\n        transactions,\r\n        miningReward,\r\n        rewardDestination,\r\n        difficulty,\r\n        nonce,\r\n    }) {\r\n        try {\r\n            let r = new RealBadBlock();\r\n            r.prevHash = prevHash;\r\n            r.blockHeight = blockHeight;\r\n            r.timestamp = new Date(timestamp);\r\n            r.transactions = transactions.map((t)=>{\r\n                return RealBadTransaction.coerce(t)\r\n            });\r\n            r.miningReward = miningReward;\r\n            r.rewardDestination = rewardDestination;\r\n            r.difficulty = difficulty;\r\n            r.nonce = nonce;\r\n\r\n            return r;\r\n        } catch (error) {\r\n            console.error(error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check that the block is sealed properly and confirm that all fields have correct non-null data types.\r\n    // This also checks that every Transaction in the block is correctly signed.\r\n    // NOTE: This does NOT mean that the Transactions are ALLOWED and CORRECT. That has to\r\n    //       be validated at the \"block chain\" level!\r\n    async isValid(minDifficulty = 256**2) {\r\n        try {\r\n            return (\r\n                // First check if the block is sealed, which will allow us to skip the work of detailed checks.\r\n                // This helps prevent us from getting spammed by garbage blocks and causing a DoS, since we can\r\n                // quickly check the seal but the seal takes a long time to make!\r\n                this.isSealed(minDifficulty)\r\n                // Note: isSealed() validates the hash quality, after which we don't care about \"difficulty\" or\r\n                //       \"nonce\" so we can skip those fields from now on.\r\n\r\n                // The previous block hash is a 32-byte hex value\r\n                && (hexToBytes(this.prevHash).length === 32)\r\n\r\n                // The blockHeight is a non-negative integer\r\n                && Number.isInteger(this.blockHeight)\r\n                && this.blockHeight >= 0\r\n\r\n                // If the blockHeight is 0, the previous hash should be all 0's as well:\r\n                && (\r\n                    this.blockHeight > 0 ||\r\n                    (this.prevHash === '00'.repeat(32))\r\n                )\r\n\r\n                // The timestamp is a Date object and contains a valid value\r\n                && (this.timestamp instanceof Date)\r\n                && !isNaN(this.timestamp.getTime())\r\n\r\n                // All the transactions have valid signatures and contain correct data types\r\n                && Array.isArray(this.transactions)\r\n                && await asyncEvery(this.transactions, async(t)=>{\r\n                    return (t instanceof RealBadTransaction) && await t.isValid();\r\n                })\r\n\r\n                // The mining reward is a non-negative finite number\r\n                && Number.isFinite(this.miningReward)\r\n                && (this.miningReward >= 0)\r\n\r\n                // The reward address is a 32-byte hex value\r\n                && (hexToBytes(this.rewardDestination).length === 32)\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","// Import the data types for manipulating coin stuff\r\nimport {\r\n    RealBadCoinTransfer,\r\n    RealBadNftMint,\r\n    RealBadNftTransfer,\r\n    RealBadTransaction,\r\n    RealBadBlock\r\n} from './RealBadCoin.tsx';\r\n\r\nexport class RealBadAccountState {\r\n    balance = 0;\r\n    nonce = 0;\r\n\r\n    static coerce({\r\n        balance,\r\n        nonce,\r\n    }) {\r\n        let r = new RealBadAccountState();\r\n        r.balance = balance;\r\n        r.nonce = nonce;\r\n        return r;\r\n    }\r\n}\r\n\r\nexport class RealBadNftState {\r\n    owner = null;\r\n\r\n    static coerce({\r\n        owner,\r\n    }) {\r\n        let r = new RealBadNftState();\r\n        r.owner = owner;\r\n        return r;\r\n    }\r\n}\r\n\r\n// Exception thrown when a transaction is invalid\r\nexport class RealBadInvalidTransaction {\r\n    message = \"\";\r\n    transaction = null;\r\n    lastBlockHash = null;\r\n\r\n    constructor(message, transaction, lastBlockHash) {\r\n        this.message = message;\r\n        this.transaction = transaction;\r\n        this.lastBlockHash = lastBlockHash;\r\n    }\r\n\r\n    toString() {\r\n        if (this.lastBlockHash !== null) {\r\n            return \"Bad Transaction in \" + this.lastBlockHash.toString() + \":\\n\" + this.message + \"\\n\" + this.transaction.toString();\r\n        } else {\r\n            return \"Bad Transaction:\\n\" + this.message + \"\\n\" + this.transaction.toString();\r\n        }\r\n    };\r\n}\r\n\r\nexport class RealBadInvalidBlock {\r\n    message = \"\";\r\n    blockHash = \"\";\r\n\r\n    constructor(message, blockHash) {\r\n        this.message = message;\r\n        this.blockHash = blockHash;\r\n    }\r\n\r\n    toString() {\r\n      return \"Bad Block \" + this.blockHash.toString() + \":\\n\" + this.message;\r\n    };\r\n}\r\n\r\nexport class RealBadFutureBlock extends RealBadInvalidBlock {\r\n    blockTimestamp : Date;\r\n\r\n    constructor(message, blockHash, blockTimestamp) {\r\n        super(message, blockHash);\r\n        this.blockTimestamp = new Date(blockTimestamp);\r\n    }\r\n}\r\n\r\n// This represents the state of the ledger at any given point\r\nexport class RealBadLedgerState {\r\n    accounts = {};  // List of \"accountId:RealBadAccountState\" pairs.\r\n    nfts = {};      // List of \"nftId:RealBadNftState\" pairs.\r\n    transactionFees = 0;\r\n\r\n    // Initialize the \"last block\" info with the \"pre-genesis block\"\r\n    lastBlockHash = '00'.repeat(32);\r\n    lastBlockHeight = -1;\r\n\r\n    // This is the target difficulty, based on the timestamps between each block\r\n    nextBlockDifficulty = null; // Difficulty of a genesis block!\r\n    lastBlockTimestamp = null;\r\n\r\n    // This is the sum of all difficulty metrics for all blocks in the chain leading up to this state.\r\n    // It is used to determine which chain represents the highest block.\r\n    totalDifficulty = 0n;\r\n\r\n    // All errors for the entire chain up until this point.\r\n    // Errors just keep stacking, but only one is needed to invalidate a chain!\r\n    errors = [];\r\n\r\n    // Hashes of the children of a this block so we can produce pretty graphs later.\r\n    // NOTE: This property is not inherited when cloning into a child block!\r\n    children = [];\r\n\r\n    // Tracked account and account tracking info\r\n    trackedAccount = null;\r\n\r\n    // Ledger entries for the tracked account\r\n    // This will contain every event that changed the balance for the tracked account.\r\n    // Format is {txId: transaction id, delta: change for myself} or {block: block hash, delta: change for myself}\r\n    accountLedger = [];\r\n\r\n    // Ledger entries for every NFT\r\n    // This will contain every event that created or changed ownership for every NFT.\r\n    // Format is {nftId: [minting tx id, transfer 1 tx id, transfer 2 tx id, ...]}\r\n    nftLedger = {};\r\n\r\n    // All the data payloads for each NFT in the history keyed by nftId.\r\n    // Note: These are shallow-copied between states!\r\n    nftPayloads = {};\r\n\r\n    // Can assign the genesis block difficulty in the constructor\r\n    constructor(genesisDifficulty = 2e6) {\r\n        this.nextBlockDifficulty = genesisDifficulty;\r\n    }\r\n\r\n    static coerce({\r\n        accounts,\r\n        nfts,\r\n        transactionFees,\r\n        lastBlockHash,\r\n        lastBlockHeight,\r\n        nextBlockDifficulty,\r\n        lastBlockTimestamp,\r\n        totalDifficulty,\r\n        errors,\r\n        children,\r\n        trackedAccount,\r\n        accountLedger,\r\n        nftLedger,\r\n        nftPayloads,\r\n    }) {\r\n        let r = new RealBadLedgerState();\r\n        Object.keys(accounts).forEach(k=>{\r\n            r.accounts[k] = RealBadAccountState.coerce(accounts[k]);\r\n        });\r\n        Object.keys(nfts).forEach(k=>{\r\n            r.nfts[k] = RealBadNftState.coerce(nfts[k]);\r\n        });\r\n        r.transactionFees = transactionFees;\r\n        r.lastBlockHash = lastBlockHash;\r\n        r.lastBlockHeight = lastBlockHeight;\r\n        r.nextBlockDifficulty = nextBlockDifficulty;\r\n        r.lastBlockTimestamp = new Date(lastBlockTimestamp);\r\n        r.totalDifficulty = BigInt(totalDifficulty);\r\n        r.errors = errors.map(e=>{\r\n            if(\"blockTimestamp\" in e) {\r\n                return new RealBadFutureBlock(e.message, e.blockHash, e.blockTimestamp);\r\n            }\r\n            else if (\"blockHash\" in e) {\r\n                return new RealBadInvalidBlock(e.message, e.blockHash);\r\n            }\r\n            else {\r\n                return new RealBadInvalidTransaction(e.message, e.transaction, e.lastBlockHash);\r\n            }\r\n        });\r\n        r.children = children;\r\n        r.trackedAccount = trackedAccount;\r\n        r.accountLedger = Array.from(accountLedger);\r\n        r.nftLedger = JSON.parse(JSON.stringify(nftLedger));\r\n        r.nftPayloads = {...nftPayloads}; // Shallow copy!\r\n        return r;\r\n    }\r\n\r\n    // Flatten down to values that can be saved as JSON\r\n    toJSON() {\r\n        return {\r\n            accounts: this.accounts,\r\n            nfts: this.nfts,\r\n            transactionFees: this.transactionFees,\r\n            lastBlockHash: this.lastBlockHash,\r\n            lastBlockHeight: this.lastBlockHeight,\r\n            nextBlockDifficulty: this.nextBlockDifficulty,\r\n            lastBlockTimestamp: this.lastBlockTimestamp,\r\n            totalDifficulty: this.totalDifficulty.toString(),\r\n            errors: this.errors,\r\n            children: this.children,\r\n            trackedAccount: this.trackedAccount,\r\n            accountLedger: this.accountLedger,\r\n            nftLedger: this.nftLedger,\r\n            nftPayloads: this.nftPayloads,\r\n        };\r\n    }\r\n\r\n    // Return a deep-ish copy clone of the state\r\n    clone() {\r\n        return RealBadLedgerState.coerce(this);\r\n    }\r\n\r\n    // Try and apply a transaction to the current state\r\n    // Raises exception and doesn't change the state if it creates an unpermissible condition\r\n    // Assumes that you've already checked that the transaction is VALID!\r\n    tryTransaction(t, ignoreBlockTimestamp : boolean = false) {\r\n        // Don't allow transactions to have a timestamp AFTER the block timestamp:\r\n        if (!ignoreBlockTimestamp && (t.timestamp > this.lastBlockTimestamp)) throw new RealBadInvalidTransaction(\"Transaction timestamp is newer than block timestamp!\", t, this.lastBlockHash);\r\n\r\n        if (t.txData instanceof RealBadCoinTransfer) {\r\n            if (!(t.source in this.accounts)) throw new RealBadInvalidTransaction(\"Account tried to send coins before it existed\", t, this.lastBlockHash);\r\n            if (t.sourceNonce !== this.accounts[t.source].nonce + 1) throw new RealBadInvalidTransaction(\"Incorrect nonce\", t, this.lastBlockHash);\r\n            if (t.txData.amount + t.transactionFee > this.accounts[t.source].balance) throw new RealBadInvalidTransaction(\"Insufficient balance\", t, this.lastBlockHash);\r\n\r\n            // Consume the money spent from this account:\r\n            let txDelta = 0;\r\n            this.accounts[t.source].nonce++;\r\n            this.accounts[t.source].balance -= t.txData.amount + t.transactionFee;\r\n            if (this.trackedAccount === t.source) txDelta -= t.txData.amount + t.transactionFee;\r\n\r\n            // Give the money to the other accounts, creating them if needed:\r\n            this.transactionFees += t.transactionFee;\r\n            if (!(t.txData.destination in this.accounts)) this.accounts[t.txData.destination] = new RealBadAccountState();\r\n            this.accounts[t.txData.destination].balance += t.txData.amount;\r\n            if (this.trackedAccount === t.txData.destination) txDelta += t.txData.amount;\r\n\r\n            if ((this.trackedAccount === t.source) || (this.trackedAccount === t.txData.destination)) {\r\n                this.accountLedger.push({txId: t.txId, delta: txDelta});\r\n            }\r\n        }\r\n        else if (t.txData instanceof RealBadNftMint) {\r\n            // See if the NFT already exists\r\n            if (t.txData.nftId in this.nfts) throw new RealBadInvalidTransaction(\"NFT Mint attempted on already-existing NFT ID\", t, this.lastBlockHash);\r\n\r\n            // Accounts must exist to perform an NFT Mint, because the nonce is incremented.\r\n            // If it doesn't exist yet, create it with a 0 nonce. This transaction's nonce should then be \"1\" to succeed.\r\n            if (!(t.source in this.accounts)) this.accounts[t.source] = new RealBadAccountState();\r\n\r\n            // Verify the nonce\r\n            if (t.sourceNonce !== this.accounts[t.source].nonce + 1) throw new RealBadInvalidTransaction(\"Incorrect nonce for NFT Mint txFee\", t, this.lastBlockHash);\r\n\r\n            // See if they can pay the transaction fee\r\n            if (t.transactionFee > this.accounts[t.source].balance) throw new RealBadInvalidTransaction(\"Insufficient balance for NFT Mint txFee\", t, this.lastBlockHash);\r\n\r\n            // Increment the nonce\r\n            this.accounts[t.source].nonce++;\r\n\r\n            if (t.transactionFee > 0) {\r\n                // Consume the money spent from this account:\r\n                this.accounts[t.source].balance -= t.transactionFee;\r\n\r\n                // Accept the transaction fee:\r\n                this.transactionFees += t.transactionFee;\r\n            }\r\n\r\n            // Always track this transaction for the source account, even if the transaction fee is 0\r\n            if (this.trackedAccount === t.source) this.accountLedger.push({txId: t.txId, delta: -t.transactionFee});\r\n\r\n            // Create the NFT and claim it for this account\r\n            let nft = new RealBadNftState();\r\n            nft.owner = t.source;\r\n            this.nfts[t.txData.nftId] = nft;\r\n\r\n            // Keep track of NFT activities in the state\r\n            // The first \"activity\" is this minting event, and we need to be able to find it in order to get the NFT data later.\r\n            this.nftLedger[t.txData.nftId] = [t.txId];\r\n            this.nftPayloads[t.txData.nftId] = t.txData.nftData;\r\n        }\r\n        else if (t.txData instanceof RealBadNftTransfer) {\r\n            let nftid = t.txData.nftId;\r\n            if (!(nftid in this.nfts)) throw new RealBadInvalidTransaction(\"NFT Transfer attempted on non-existent NFT ID\", t, this.lastBlockHash);\r\n            if (this.nfts[nftid].owner !== t.source) throw new RealBadInvalidTransaction(\"NFT Transfer attempted by non-owner of NFT\", t, this.lastBlockHash);\r\n\r\n            // Accounts must exist to perform an NFT Transfer, because we create them for NFT Mint and when receiving an NFT in a Transfer.\r\n            if (!(t.source in this.accounts)) throw new RealBadInvalidTransaction(\"Account tried to send NFT before it existed\", t, this.lastBlockHash);\r\n\r\n            // Verify the nonce\r\n            if (t.sourceNonce !== this.accounts[t.source].nonce + 1) throw new RealBadInvalidTransaction(\"Incorrect nonce for NFT Transfer txFee\", t, this.lastBlockHash);\r\n\r\n            // See if they can pay the transaction fee\r\n            if (t.transactionFee > this.accounts[t.source].balance) throw new RealBadInvalidTransaction(\"Insufficient balance for NFT Transfer txFee\", t, this.lastBlockHash);\r\n\r\n            // Increment the nonce\r\n            this.accounts[t.source].nonce++;\r\n\r\n            if (t.transactionFee > 0) {\r\n                // Consume the money spent from this account:\r\n                this.accounts[t.source].balance -= t.transactionFee;\r\n\r\n                // Accept the transaction fee:\r\n                this.transactionFees += t.transactionFee;\r\n            }\r\n\r\n            // Track this for the source and/or destination accounts regardless of transaction fee\r\n            if (this.trackedAccount === t.source) this.accountLedger.push({txId: t.txId, delta: -t.transactionFee});\r\n            else if (this.trackedAccount === t.txData.destination) this.accountLedger.push({txId: t.txId, delta: 0});\r\n\r\n            // Create a destination account if it doesn't already exist\r\n            // We aren't giving it any money, but we want to show the account status to view the NFT!\r\n            if (!(t.txData.destination in this.accounts)) this.accounts[t.txData.destination] = new RealBadAccountState();\r\n\r\n            // Enjoy your shiny new NFT!\r\n            this.nfts[nftid].owner = t.txData.destination;\r\n\r\n            this.nftLedger[t.txData.nftId].push(t.txId);\r\n        }\r\n    }\r\n\r\n    // Try and apply a block to the current state\r\n    // Returns a new RealBadLedgerState with the block applied if successful. Otherwise returns null.\r\n    // Assumes that you've already checked that the block is VALID and that you approve of the mining reward amount!\r\n    applyBlock(block) {\r\n        const hash = block.hash;\r\n        // Make a deep copy of ourselves\r\n        let s = this.clone();\r\n        s.children = []; // Brand new state doesn't have children\r\n\r\n        // Add the block as a child of \"this\".\r\n        // NOTE: When a block that was from the future gets \"reconsidered\" it can cause this function\r\n        // to get called multiple times with the same block, so we DO have to check for uniqueness when inserting children!\r\n        if (!this.children.includes(hash)) this.children.push(hash);\r\n\r\n        // First just check if the new block fits as the next block in the block chain\r\n        if (block.prevHash !== this.lastBlockHash) s.errors.push(new RealBadInvalidBlock(\"Block does not point at this state's prevHash\", hash));\r\n        if (block.blockHeight !== this.lastBlockHeight + 1) s.errors.push(new RealBadInvalidBlock(\"Block height is not lastBlockHeight + 1\", hash));\r\n        if (block.timestamp > new Date(Date.now() + 5*1000)) s.errors.push(new RealBadFutureBlock(\"Block timestamp is from the future!\", hash, block.timestamp));\r\n        if ((block.blockHeight !== 0) && (block.timestamp < this.lastBlockTimestamp)) s.errors.push(new RealBadInvalidBlock(\"Block timestamp is not greater than last block's timestamp\", hash));\r\n\r\n        s.lastBlockHash = hash;\r\n        s.lastBlockHeight = block.blockHeight;\r\n        let blockTimeDelta = (block.blockHeight === 0) ? 0 : Math.max(0, block.timestamp - this.lastBlockTimestamp);\r\n        s.lastBlockTimestamp = block.timestamp;\r\n\r\n        // The difficulty metric is proportional to how low the hash is relative to the \"zero difficulty\" level.\r\n        // The lower the hash as an integer, the bigger the difficulty.\r\n        // When you sum this metric from two blocks, it is equivalent to having solved one block with twice the difficulty.\r\n        s.totalDifficulty = this.totalDifficulty + RealBadBlock.difficultyMetric(s.lastBlockHash);\r\n\r\n        // Check if they tried hard enough\r\n        if (block.difficulty < this.nextBlockDifficulty) s.errors.push(new RealBadInvalidBlock(\"Block's target difficulty is too low\", hash));\r\n\r\n        // Check if we approve of the mining reward.\r\n        // TODO: Make something cooler than a hard-coded fixed limit!\r\n        if (block.miningReward > 100) s.errors.push(new RealBadInvalidBlock(\"Block reward is too high!\", hash));\r\n\r\n        // Re-target the difficulty based on how long this last block took to harvest\r\n        // This uses a long-running \"leaky integrator\" IIR filter to low-pass filter the block gaps\r\n        // until we reach an equilibrium. But everybody can easily compute the next result based only on\r\n        // the last two timestamps!\r\n        if (block.blockHeight === 0) {\r\n            // The first 2 blocks get the same \"genesis difficulty\":\r\n            s.nextBlockDifficulty = this.nextBlockDifficulty;\r\n        }\r\n        else {\r\n            let errorRatio = blockTimeDelta / (15 * 1000); // Targeting 15 seconds per block\r\n            // Exponential moving average (EMA) approximation\r\n            // NOTE: We clamp the error ratio between 0 and 2 so that even if we get EXTREMELY long gaps we\r\n            // don't adjust more than 1/N in either direction!\r\n            errorRatio = Math.min(2, errorRatio);\r\n            const N = 40; // Number of blocks of \"smoothing\" effect.\r\n            s.nextBlockDifficulty = Math.round(this.nextBlockDifficulty * (1 + (1 - errorRatio) / N));\r\n        }\r\n        //console.log(\"Target difficulty after block \" + s.lastBlockHeight.toString() + \" is \" + s.nextBlockDifficulty.toString());\r\n\r\n        // Attempt to apply all the transactions\r\n        try {\r\n            block.transactions.forEach(t => {\r\n                s.tryTransaction(t);\r\n            });\r\n        } catch (error) {\r\n            s.errors.push(error);\r\n        }\r\n\r\n        // Keep a maximum of 100 errors per block!\r\n        s.errors = s.errors.slice(-100);\r\n\r\n        // If successful, pay the mining rewards, including the sum of transactionFees from all transactions.\r\n        if (!(block.rewardDestination in s.accounts)) s.accounts[block.rewardDestination] = new RealBadAccountState();\r\n        s.accounts[block.rewardDestination].balance += block.miningReward + s.transactionFees;\r\n        if (s.trackedAccount === block.rewardDestination) s.accountLedger.push({block: hash, delta: block.miningReward + s.transactionFees});\r\n\r\n        // Clear out transaction fees now that they are claimed\r\n        s.transactionFees = 0;\r\n\r\n        // Only show the last 3 errors in a block to avoid mega-spamming the console.\r\n        // Also only showing as \"warning\" to prevent showing stack traces on each one.\r\n        if (s.errors.length) console.warn(s.errors.length.toString() + \" errors in block \" + block.blockHeight + \". Last 3: \" + JSON.stringify(s.errors.slice(-3)));\r\n\r\n        return s;\r\n    }\r\n}\r\n\r\n// Keep track of a set of blocks and provide helper functions for identifying the longest chain, etc.\r\n// NOTE: This is a LOCAL data structure and is not something that can be trusted if it is sent from elsewhere!\r\nexport class RealBadCache {\r\n    _blocks = {};               // Key/value pairs with key as block hash and full state of system as the value\r\n    _anticipatedBlocks = {};    // Key/value pairs with key as \"prevHash\" for blocks that don't exist in our cache yet, and value as a list of blocks waiting on them to arrive.\r\n    _readyBlocks = [];          // List of hashes of blocks that are marked as \"ready for processing state\". They are pulled from _anticipatedBlocks once their ancestor is done processing.\r\n    _bestBlock = null;          // Hash of the top-scoring block (i.e. the one with the deepest block chain \"strength\")\r\n    _minTxFee = 0;              // Minimum transaction fee for transactions to be include by makeMineableBlock()\r\n    _txPool = {};               // Pool of un-confirmed transactions that we can try add to a block.\r\n    _recentConfirmedTx = {};    // Pool of recently confirmed transactions so we can avoid repeating them.\r\n    _txToBlocks = {};           // Pool of transactions with list of blocks that they are in (yes, a Tx can be in more than one block, but only one per chain!)\r\n    _lastMiningRoot = null;     // This is the last block we attempted to mine on top of.\r\n    _isCheckpoint = false;      // Are we building from a checkpoint, or have we validated the checkpoint block?\r\n    minDifficulty = 256**2;     // Minimum difficulty level of blocks to allow into our cache.\r\n    genesisDifficulty = 2e6;    // Difficulty of genesis blocks\r\n    myAccount = null;           // What account is being used for state tracking (\"Tx History\")\r\n    txIdToReject = null;        // A transaction to reject so we can try and delete it from the block chain\r\n\r\n    constructor(myAccount) {\r\n        this.myAccount = myAccount;\r\n    }\r\n\r\n    // Only accept good RealBadBlocks into our cache!\r\n    async addBlock(block, minDifficulty=this.minDifficulty) {\r\n        try {\r\n            let hash = block.hash; // Save us the trouble of recomputing this tons of times!\r\n            if (\r\n                // Make sure its a valid sealed block\r\n                (block instanceof RealBadBlock)\r\n                && await block.isValid(minDifficulty)\r\n\r\n                // Also make sure we haven't seen it before\r\n                && !(hash in this._blocks)\r\n            ) {\r\n                // This is a new block, so create the info object with just the block and originator for now.\r\n                this._blocks[hash] = {\r\n                    block: block,\r\n                };\r\n\r\n                // Check if this block is a genesis block or is linked to a block with a valid already-computed state\r\n                if ((block.blockHeight === 0) || ((block.prevHash in this._blocks) && (\"state\" in this._blocks[block.prevHash]))) {\r\n                    // Special check for anachronistic blocks.\r\n                    // If this block has any parents that were \"from the future\" at the time but are now OK, we want\r\n                    // to re-visit them and update their state before processing this block.\r\n                    // This is because we want to accept blocks that are out of sync _if everybody else does_, because that means\r\n                    // that _we_ are the ones with the bad clock. :shrug:\r\n                    if (block.blockHeight !== 0) {\r\n                        const parentErrors = this.getState(block.prevHash).errors;\r\n                        for(let e of parentErrors) {\r\n                            // If the block is OK now, then dump it and all of its children into the \"ready\" queue to get reevaluated\r\n                            if (e instanceof RealBadFutureBlock) {\r\n                                if (e.blockTimestamp <= new Date(Date.now() + 5*1000)) {\r\n                                    // Dump this block and all its children into the hash\r\n                                    this._readyBlocks = [e.blockHash].concat(this.getChain(block.prevHash, e.blockHash));\r\n\r\n                                    // Note: Quit once we find the first (aka OLDEST) one, since we're going to refresh all the children as well.\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this._readyBlocks.push(hash);\r\n                }\r\n                else {\r\n                    // Otherwise (can't compute the state yet), add this block to the \"watch list\" for later computation\r\n                    // once we fill in the missing links.\r\n                    if (!(block.prevHash in this._anticipatedBlocks)) this._anticipatedBlocks[block.prevHash] = [];\r\n                    this._anticipatedBlocks[block.prevHash].push(hash);\r\n\r\n                    if (this._readyBlocks.length) console.error(\"Expected _readyBlocks to be empty but there were \" + this._readyBlocks.length);\r\n                }\r\n\r\n                // Update all the blocks in the ready list\r\n                // Note that updating them might add new ones to the ready list by pulling them from _anticipatedBlocks.\r\n                // We update those too until we run out.\r\n                while (this._readyBlocks.length) {\r\n                    let h = this._readyBlocks.shift()\r\n                    let b = this.getBlock(h);\r\n\r\n                    // Check if this block is a checkpoint block\r\n                    if (this._blocks[h]?.isCheckpoint) {\r\n                        console.log(\"Synced up to checkpoint!\");\r\n                        this._isCheckpoint = false;\r\n                        delete this._blocks[h].isCheckpoint;\r\n                        continue; // Don't actually update it's state other than removing the checkpoint flag\r\n                    }\r\n\r\n                    if (b.blockHeight === 0) {\r\n                        // Genesis block!\r\n                        const blankState = new RealBadLedgerState(this.genesisDifficulty);\r\n                        blankState.trackedAccount = this.myAccount; // Track my account for this tree of ledger states!\r\n                        this._blocks[h].state = blankState.applyBlock(b);\r\n                    }\r\n                    // ASSUMPTION: Unless this is a genesis block, if it got into _readyBlocks then it's prevHash and state *is available* in our block cache!\r\n                    else {\r\n                        // The new state might be bad if this block is bad.\r\n                        this._blocks[h].state = this._blocks[b.prevHash].state.applyBlock(b);\r\n                    }\r\n\r\n                    // If our \"banned txId\" is in the block, mark it as an error so we reject the whole remaining chain of blocks!\r\n                    if (this.txIdToReject && (block.transactions.find(tx=>(tx.txId === this.txIdToReject)))) {\r\n                        this._blocks[h].state.errors.push(new RealBadInvalidBlock(\"Block contains banned transaction!\", h));\r\n                    }\r\n\r\n                    // Add back-links for all transactions in the block so we can look up every block in which a transaction is included:\r\n                    b.transactions.forEach(tx=>{\r\n                        const id = tx.txId;\r\n                        if (!(id in this._txToBlocks)) this._txToBlocks[id] = [];\r\n                        this._txToBlocks[id].push(h);\r\n                    });\r\n\r\n                    // Now that we updated a block, see if this lets us update any others, which will have us repeat the loop again.\r\n                    if (h in this._anticipatedBlocks) {\r\n                        this._readyBlocks = this._readyBlocks.concat(this._anticipatedBlocks[h]);\r\n                        delete this._anticipatedBlocks[h];\r\n                    }\r\n\r\n                    // Also now that we updated a block, see if it is now the \"best block\".\r\n                    // This is the only place where we need to check for those updates, because we just added new state that we didn't have before.\r\n                    // NOTE: The \"best\" chain is weighed based on total difficulty to create it, rather than block height!\r\n                    //       Block height is just a human-readable metric and is used to detect genesis blocks.\r\n                    let thisState = this.getState(h);\r\n                    if (thisState.errors.length === 0) {\r\n                        let bestState = this.getState(this._bestBlock);\r\n                        if (\r\n                            (bestState === null) ||\r\n                            (thisState.totalDifficulty > bestState.totalDifficulty)\r\n                        ) {\r\n                            this._bestBlock = h;\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        } catch (error) {\r\n            console.error(error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Apply a checkpoint based on known good block\r\n    // This can let the account get \"up to speed\" quickly while it then churns through\r\n    // the process of downloading additional blocks in the background.\r\n    restoreCheckpoint(block, state) {\r\n        // Just inject it directly in there and call it our \"best\":\r\n        const hash = block.hash;\r\n        this._bestBlock = hash;\r\n        this._blocks[hash] = {\r\n            block: block,\r\n            state: state,\r\n            isCheckpoint: true, // Mark this block as the \"checkpoint\"\r\n        }\r\n        this._isCheckpoint = true; // Mark the cache as \"checkpointed\"\r\n\r\n        // Add our parent to the _anticipatedBlocks list so we can update our \"isCheckpoint\" state once we re-compute this block's state.\r\n        if (!(block.prevHash in this._anticipatedBlocks)) this._anticipatedBlocks[block.prevHash] = [];\r\n        this._anticipatedBlocks[block.prevHash].push(hash);\r\n    }\r\n\r\n    get isCheckpoint() {\r\n        return this._isCheckpoint;\r\n    }\r\n\r\n    // Return hash of the best block that we know about:\r\n    get bestBlockHash() {\r\n        return this._bestBlock;\r\n    }\r\n\r\n    getBlock(hash) {\r\n        if (hash in this._blocks) {\r\n            return this._blocks[hash].block;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getState(hash) {\r\n        if ((hash in this._blocks) && (\"state\" in this._blocks[hash])) {\r\n            return this._blocks[hash].state;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Return list with all blocks in the chain.\r\n    // Stops when it runs out of previous blocks (or hits a genesis block).\r\n    // Also stops early when it hits rootHash if that is part of the chain.\r\n    // If `hash` is null-ish, then it will assume you want the top of the \"best chain\".\r\n    getChain(hash, rootHash=null, maxLength=Infinity) {\r\n        let chain = [];\r\n        let currHash = hash ?? this.bestBlockHash;\r\n        let currBlock = this.getBlock(currHash);\r\n\r\n        while ((currHash !== rootHash) && (currBlock !== null) && (chain.length < maxLength)) {\r\n            chain.unshift(currHash);\r\n\r\n            // Stop when we hit genesis block\r\n            if (currBlock.blockHeight === 0) break;\r\n\r\n            currHash = currBlock.prevHash;\r\n            currBlock = this.getBlock(currHash);\r\n        }\r\n\r\n        return chain;\r\n    }\r\n\r\n    // Return the common parent of both of these blocks, if such a thing exists.\r\n    getCommonParent(hash1, hash2, maxLength=Infinity) {\r\n        // Obvious short-circuit option:\r\n        if (hash1 === hash2) return hash1;\r\n\r\n        for(let i = 0; i < maxLength; i++) {\r\n            const b1 = this.getBlock(hash1);\r\n            // This happens when we hit the top of the chain or genesis block without finding a match\r\n            if (!b1) return null;\r\n            const h1 = b1.blockHeight;\r\n\r\n            const b2 = this.getBlock(hash2);\r\n            if (!b2) return null;\r\n            const h2 = b2.blockHeight;\r\n\r\n            // Figure out which block is further ahead, and walk it back to be equal\r\n            const minHeight = Math.min(h1, h2);\r\n            if (h1 > minHeight) hash1 = this.getChain(hash1, null, 1 + h1 - minHeight)[0];\r\n            if (h2 > minHeight) hash2 = this.getChain(hash2, null, 1 + h2 - minHeight)[0];\r\n\r\n            // See if they match\r\n            if (hash1 === hash2) return hash1;\r\n\r\n            // Grab the new blocks, since we know they aren't the same, and walk up one layer.\r\n            hash1 = this.getBlock(hash1).prevHash;\r\n            hash2 = this.getBlock(hash2).prevHash;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Because \"confirmations\" really applies to the _transactions_ more than the blocks themselves, the number of\r\n    // confirmations of a block is the number of blocks (including itself) after it *in the best chain*.\r\n    // If a block isn't in the best chain, its confirmations are 0! If a block is the head of the main chain, it's confirmations are 1.\r\n    getConfirmations(hash) {\r\n        // Need to find a parent of this hash that is ON the main chain if we aren't.\r\n        // We DON'T want to walk all the way up the chain every time for blocks that have 0 confirmations!\r\n        const chainParent = this.getCommonParent(hash, this.bestBlockHash, 100); // If you haven't hit \"main chain\" in 100 loops, then you aren't confirmed!\r\n\r\n        // If we are ON the main chain, then our common parent is ourself!\r\n        if (chainParent === hash) {\r\n            // Get the height of both the top hash and the hash in question.\r\n            // The confirmation level is then the difference between their blockHeights.\r\n            // We can do this shortcut becuase we trust the blockHeight claims of blocks on the main chain!\r\n            const thisBlock = this.getBlock(hash);\r\n            const topBlock = this.getBlock(this.bestBlockHash);\r\n            return 1 + (topBlock.blockHeight - thisBlock.blockHeight);\r\n        }\r\n        else return 0;\r\n    }\r\n\r\n    getBlocksWithTransaction(txId) {\r\n        if (txId in this._txToBlocks) {\r\n            return this._txToBlocks[txId];\r\n        } else return [];\r\n    }\r\n\r\n    // Validate and possibly add a transaction into the memory pool.\r\n    // If the transaction is VALID and NEW, then return true.\r\n    async addTransaction(tx) {\r\n        try {\r\n            if (\r\n                // Make sure its a valid signed Tx\r\n                (tx instanceof RealBadTransaction)\r\n                && await tx.isValid()\r\n\r\n                // Make sure it's timestamp isn't (too far) in the future or too far in the past\r\n                // NOTE: We will only APPLY transactions if they are in the past and\r\n                // less than 5 minutes old, according to our clock, but we'll put it in the memory pool\r\n                // even if it is up to 5 minute into the future! This is in case our clock is slower than\r\n                // the rest of the network but we still want to service transactions.\r\n                && (tx.timestamp < new Date(Date.now() + 5*60*1000))\r\n                && (Date.now() - tx.timestamp < 5*60*1000) // We only keep them for 5 minutes\r\n\r\n                // Also quit early if we already have this one!\r\n                && !(tx.txId in this._txPool)\r\n                && !(tx.txId in this._recentConfirmedTx)\r\n                && !(tx.txId === this.txIdToReject)\r\n            ) {\r\n                // This is a new transaction that we haven't seen recently!\r\n                this._txPool[tx.txId] = tx;\r\n                return true;\r\n            }\r\n        } catch (error) {\r\n            console.error(error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Get the pool of transactions that are eligible for mining\r\n    getTxPool() {\r\n        return this._txPool;\r\n    }\r\n\r\n    // Set the minimum transaction fee that we will accept and mine into a block\r\n    setMinTxFee(fee) {\r\n        this._minTxFee = fee;\r\n    }\r\n\r\n    // Create the next block for mining, based on the best known block plus\r\n    // whatever valid transactions we can grab from the txPool\r\n    makeMineableBlock(reward, destination) {\r\n        let prevHash = this.bestBlockHash ?? '00'.repeat(32);\r\n\r\n        if (this._lastMiningRoot !== prevHash) {\r\n            // Need to reshuffle the transaction pools if the mining root is different this time!\r\n\r\n            // Find the point at which the branches containing the old and new prevHash split\r\n            // apart (might be null if they are entirely different trees or are too far apart!)\r\n            const sharedRoot = this.getCommonParent(this._lastMiningRoot, prevHash, 100);\r\n\r\n            // Also include some level of sanity in the search by limiting our history to 100 blocks.\r\n            let oldChain = this.getChain(this._lastMiningRoot, sharedRoot, 100);\r\n            let newChain = this.getChain(prevHash, sharedRoot, 100);\r\n\r\n            // These are \"Removed\" blocks. All transactions in them should be added to the tx pool\r\n            let removedBlocks = oldChain.filter((b, i)=>!newChain.includes(b));\r\n            removedBlocks.forEach(h=>{\r\n                let b = this.getBlock(h);\r\n                b.transactions.forEach(t=>{\r\n                    // NOTE: This can cause really really old transactions to reenter the pool. :shrug:\r\n                    this._txPool[t.txId] = t;\r\n\r\n                    // Remove from recently confirmed pool:\r\n                    delete this._recentConfirmedTx[t.txId];\r\n                });\r\n            });\r\n\r\n            // These are \"Added\" blocks. All transactions in them should be removed from the tx pool\r\n            let addedBlocks = newChain.filter((b, i)=>!oldChain.includes(b));\r\n            addedBlocks.forEach(h=>{\r\n                let b = this.getBlock(h);\r\n                b.transactions.forEach(t=>{\r\n                    // Add them to recently confirmed pool, but only if they are \"recent\":\r\n                    if (\r\n                        (t.timestamp < new Date(Date.now() + 5*60*1000))\r\n                        && (Date.now() - t.timestamp < 5*60*1000)\r\n                    ) {\r\n                        this._recentConfirmedTx[t.txId] = t;\r\n                    }\r\n\r\n                    // Remove from txPool:\r\n                    delete this._txPool[t.txId];\r\n                });\r\n            });\r\n\r\n            // Save our \"last mining block\" for next time!\r\n            this._lastMiningRoot = prevHash;\r\n        }\r\n\r\n        // Get the info for the previous block that we're going to build upon.\r\n        // NOTE: This might be null!\r\n        let lastBlock = this.getBlock(prevHash);\r\n        let lastBlockState = this.getState(prevHash) ?? new RealBadLedgerState(this.genesisDifficulty);\r\n        let prevHeight = lastBlock?.blockHeight ?? -1;\r\n\r\n        let b = new RealBadBlock();\r\n        b.prevHash = prevHash;\r\n        b.blockHeight = prevHeight + 1;\r\n        b.difficulty = lastBlockState.nextBlockDifficulty;\r\n        b.miningReward = reward;\r\n        b.rewardDestination = destination;\r\n        // Set the block's timestamp to at least _slightly_ ahead of the last block so that we\r\n        // don't allow timestamps to go backward!\r\n        const minTimestampMs = Number(lastBlock?.timestamp ?? Date.now()) + 1;\r\n        b.timestamp = new Date(Math.max(minTimestampMs, Date.now()));\r\n\r\n        // Delete any transactions from the pool that are too old\r\n        for (const txId of Object.keys(this._txPool)) {\r\n            const t = this._txPool[txId];\r\n            if ((t.timestamp > new Date(Date.now() + 5*60*1000))\r\n                || (Date.now() - t.timestamp > 5*60*1000)\r\n                // Or if they are rejected!\r\n                || (txId === this.txIdToReject)\r\n            ) {\r\n                delete this._txPool[t.txId];\r\n            }\r\n        }\r\n\r\n        // Try and add as many transactions to the block as will create a valid state\r\n        let s = lastBlockState.clone();\r\n        let poolCopy = [];\r\n        for (const txId in this._txPool) {\r\n            // Ignore the cheapskates and only consider transactions that meet our minimum transaction fee level\r\n            if (this._txPool[txId].transactionFee >= this._minTxFee) poolCopy.push(txId);\r\n        }\r\n\r\n        // Special case to modify the \"state\" that we are trying transactions on:\r\n        // We want to accept transactions that are older than \"this\" block but we can't\r\n        // use \"applyBlock\" here because it would allow a miner to spend the reward in the same block.\r\n        // So we apply _only_ the \"timestamp\" to the state.\r\n        s.lastBlockTimestamp = b.timestamp;\r\n\r\n        // Transactions only \"work\" in certain orders, so try our best to find that order.\r\n        // We're going to loop until we don't get any new valid transactions\r\n        // in a pass through the list\r\n        while (true) {\r\n            let newTransactions = [];\r\n            poolCopy.forEach(txId=>{\r\n                try {\r\n                    s.tryTransaction(this._txPool[txId]);\r\n                    newTransactions.push(txId);\r\n                } catch (error) {\r\n                    if (!(error instanceof RealBadInvalidTransaction)) {\r\n                        throw error;\r\n                    }\r\n                }\r\n            });\r\n\r\n            // When we stop making progress, quit!\r\n            if (newTransactions.length === 0) break;\r\n\r\n            // Put the new transactions in the block\r\n            b.transactions = b.transactions.concat(newTransactions.map(txId=>this._txPool[txId]));\r\n\r\n            // Remove them from further consideration\r\n            poolCopy = poolCopy.filter((txId, i)=>!newTransactions.includes(txId));\r\n        }\r\n        return b;\r\n    }\r\n}\r\n","// This is a background thread that will manage the validation and storage of\r\n// blocks, to offload the work from the UI thread\r\nimport * as Comlink from 'comlink';\r\n\r\nimport {\r\n    RealBadBlock,\r\n    RealBadTransaction,\r\n} from './RealBadCoin.tsx';\r\n\r\nimport {\r\n    RealBadCache,\r\n    RealBadLedgerState,\r\n    RealBadInvalidBlock,\r\n} from './RealBadState.tsx';\r\n\r\nclass CacheWorker {\r\n    #cache;\r\n\r\n    constructor(myAccount) {\r\n        this.#cache = new RealBadCache(myAccount);\r\n    }\r\n\r\n    // Validate and possibly add a block to the cache\r\n    async addBlock(block) {\r\n        let b = RealBadBlock.coerce(block);\r\n        return await this.#cache.addBlock(b);\r\n    }\r\n\r\n    // Validate and possibly add a list of blocks to the cache\r\n    async addBlocks(blockList) {\r\n        let anyGood = false;\r\n        for (let b of blockList) {\r\n            // WARNING: The order of the operands matters here, due to lazy execution!\r\n            anyGood = await this.addBlock(b) || anyGood;\r\n        }\r\n        return anyGood;\r\n    }\r\n\r\n    restoreCheckpoint(block, state) {\r\n        this.#cache.restoreCheckpoint(\r\n            RealBadBlock.coerce(block),\r\n            RealBadLedgerState.coerce(state),\r\n        );\r\n    }\r\n\r\n    // Identify if we are working from a checkpoint or if we have a full chain\r\n    get isCheckpoint() {\r\n        return this.#cache.isCheckpoint;\r\n    }\r\n\r\n    // Return all the info about one block from the cache\r\n    getBlockInfo(hash) {\r\n        return {\r\n            block: this.#cache.getBlock(hash),\r\n            state: this.#cache.getState(hash),\r\n        };\r\n    }\r\n\r\n    // Get a list of blocks (just the blocks, not full info!) matching the list of hashes.\r\n    getBlocks(hashList) {\r\n        return hashList.map((h, i)=>this.#cache.getBlock(h));\r\n    }\r\n\r\n    getCommonParent(hash1, hash2, maxLength=Infinity) {\r\n        return this.#cache.getCommonParent(hash1, hash2, maxLength);\r\n    }\r\n\r\n    // Get the list of hashes comprising the chain, starting at `hash` and going\r\n    // backward until `rootHash` is found (or a genesis block, or a block with no parent).\r\n    // If topHash is null or undefined, then we start at the \"best\" hash.\r\n    getChain(hash, rootHash=null, maxLength=Infinity) {\r\n        return this.#cache.getChain(hash, rootHash, maxLength);\r\n    }\r\n\r\n    // Get the number of \"confirmations\" for a particular block (i.e. how many blocks, including itself,\r\n    // are on the main chain after it).\r\n    getConfirmations(hash) {\r\n        return this.#cache.getConfirmations(hash);\r\n    }\r\n\r\n    // Return the hash of the top of the \"best chain\" that we know about\r\n    get bestBlockHash() {\r\n        return this.#cache.bestBlockHash;\r\n    }\r\n\r\n    // Validate and possibly add a transaction into the memory pool.\r\n    // If the transaction is VALID and NEW, then return true.\r\n    async addTransaction(transaction) {\r\n        let tx = RealBadTransaction.coerce(transaction);\r\n        return await this.#cache.addTransaction(tx);\r\n    }\r\n\r\n    getBlocksWithTransaction(txId) {\r\n        return this.#cache.getBlocksWithTransaction(txId);\r\n    }\r\n\r\n    getTxPool() {\r\n        return this.#cache.getTxPool();\r\n    }\r\n\r\n    setMinTxFee(fee) {\r\n        this.#cache.setMinTxFee(fee);\r\n    }\r\n\r\n    makeMineableBlock(reward, destination) {\r\n        return this.#cache.makeMineableBlock(reward, destination);\r\n    }\r\n\r\n    // Reject a transaction so you can attempt to undo it.\r\n    // This will pick the block _above_ this transaction as the new root, and re-compute\r\n    // all the state above that point, rejecting this transaction _every time_ it appears.\r\n    cancelTransaction(txIdToReject = null) {\r\n        // Keep track so we never accept this transaction again!\r\n        this.#cache.txIdToReject = txIdToReject;\r\n\r\n        // Find all blocks with this transaction\r\n        const blockHashes = this.#cache.getBlocksWithTransaction(txIdToReject);\r\n\r\n        // Mark them and all their children as being error blocks\r\n        for (const hash of blockHashes) {\r\n            const error = new RealBadInvalidBlock(\"Block contains banned transaction!\", hash);\r\n            const state = this.#cache.getState(hash);\r\n            let childHashes = [];\r\n            if (state) {\r\n                state.errors.push(error);\r\n                childHashes.push(state.children);\r\n            }\r\n\r\n            while (childHashes.length) {\r\n                const ch = childHashes.shift();\r\n                const state = this.#cache.getState(ch);\r\n                if (state) {\r\n                    state.errors.push(error);\r\n                    childHashes.push(state.children);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Now find which remaining block in the cache has the highest difficulty ranking.\r\n        // It's _probably_ one of the parents of the recently-burned blocks, but\r\n        // we're going to just brute force it anyway.\r\n        this.#cache._bestBlock = null;\r\n        for (const h of Object.keys(this.#cache._blocks)) {\r\n            let thisState = this.#cache.getState(h);\r\n            if (thisState?.errors?.length === 0) {\r\n                let bestState = this.#cache.getState(this.#cache._bestBlock);\r\n                if ((bestState === null) ||\r\n                    (thisState.totalDifficulty > bestState.totalDifficulty)\r\n                ) {\r\n                    this.#cache._bestBlock = h;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nComlink.expose(CacheWorker);\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [416], () => (__webpack_require__(2455)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"6bff7d5d\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t475: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkrealbadcoin\"] = self[\"webpackChunkrealbadcoin\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(416).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["RealBadCoinTransfer","type","destination","amount","r","isValid","this","hexToBytes","length","Number","isFinite","RealBadNftMint","nftData","nftId","hash","bytesToHex","sha256","JSON","stringify","RealBadNftTransfer","RealBadTransaction","source","sourceNonce","timestamp","transactionFee","txData","txId","signature","tx_val","Date","coerce","isInteger","isNaN","getTime","ed","account","getPubKeyHex","sign","RealBadBlock","prevHash","repeat","blockHeight","transactions","miningReward","rewardDestination","difficulty","nonce","raw_hash","toString","h","hexToBigint","isSealed","minDifficulty","Math","max","maxHash","BigInt","tryToSeal","num_attempts","now","i","map","t","error","console","Array","isArray","async","arr","predicate","e","asyncEvery","self_minus_nonce","RealBadAccountState","balance","RealBadNftState","owner","RealBadInvalidTransaction","constructor","message","transaction","lastBlockHash","RealBadInvalidBlock","blockHash","RealBadFutureBlock","blockTimestamp","super","RealBadLedgerState","genesisDifficulty","accounts","nfts","transactionFees","lastBlockHeight","nextBlockDifficulty","lastBlockTimestamp","totalDifficulty","errors","children","trackedAccount","accountLedger","nftLedger","nftPayloads","Object","keys","forEach","k","from","parse","toJSON","clone","tryTransaction","txDelta","push","delta","nft","nftid","applyBlock","block","s","includes","blockTimeDelta","difficultyMetric","errorRatio","min","N","round","slice","warn","RealBadCache","myAccount","_blocks","_anticipatedBlocks","_readyBlocks","_bestBlock","_minTxFee","_txPool","_recentConfirmedTx","_txToBlocks","_lastMiningRoot","_isCheckpoint","txIdToReject","parentErrors","getState","concat","getChain","shift","b","getBlock","isCheckpoint","log","blankState","state","find","tx","id","thisState","bestState","restoreCheckpoint","bestBlockHash","rootHash","maxLength","Infinity","chain","currHash","currBlock","unshift","getCommonParent","hash1","hash2","b1","h1","b2","h2","minHeight","getConfirmations","thisBlock","getBlocksWithTransaction","getTxPool","setMinTxFee","fee","makeMineableBlock","reward","sharedRoot","oldChain","newChain","removedBlocks","filter","addedBlocks","lastBlock","lastBlockState","prevHeight","minTimestampMs","poolCopy","newTransactions","Comlink","addBlock","blockList","anyGood","getBlockInfo","getBlocks","hashList","addTransaction","cancelTransaction","blockHashes","childHashes","ch","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","fulfilled","j","every","key","splice","d","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","data","moreModules","runtime","pop","next","then"],"sourceRoot":""}