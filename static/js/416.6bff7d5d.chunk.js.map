{"version":3,"file":"static/js/416.6bff7d5d.chunk.js","mappings":"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","sources":["../node_modules/bigint-conversion/src/ts/index.ts","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js","../node_modules/@noble/ed25519/lib/esm/index.js","../node_modules/@noble/hashes/esm/_sha2.js","../node_modules/@noble/hashes/esm/cryptoBrowser.js","../node_modules/@noble/hashes/esm/sha256.js","../node_modules/@noble/hashes/esm/utils.js","../node_modules/comlink/src/comlink.ts"],"sourcesContent":["/**\n * Conversions from/to bingint to TypedArray/Buffer, hex\n *\n * @remarks\n * This module runs perfectly in node.js and browsers\n *\n * @packageDocumentation\n */\n\nimport * as b64 from '@juanelas/base64'\n\n/**\n * A TypedArray object describes an array-like view of an underlying binary data buffer.\n */\nexport type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array\n\n/**\n * Converts an arbitrary-size non-negative bigint to an ArrayBuffer or a Buffer (default for Node.js)\n *\n * @param a\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer with a binary representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0.\n */\nexport function bigintToBuf (a: bigint, returnArrayBuffer: boolean = false): ArrayBuffer|Buffer {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return hexToBuf(bigintToHex(a), returnArrayBuffer)\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (node.js) to a bigint\n * @param buf\n * @returns a bigint\n */\nexport function bufToBigint (buf: ArrayBuffer|TypedArray|Buffer): bigint {\n  let bits = 8n\n  if (ArrayBuffer.isView(buf)) bits = BigInt(buf.BYTES_PER_ELEMENT * 8)\n  else buf = new Uint8Array(buf)\n\n  let ret = 0n\n  for (const i of (buf as TypedArray|Buffer).values()) {\n    const bi = BigInt(i)\n    ret = (ret << bits) + bi\n  }\n  return ret\n}\n\n/**\n * Converts a non-negative bigint to a hexadecimal string\n * @param a - a non negative bigint\n * @returns hexadecimal representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\nexport function bigintToHex (a: bigint): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return a.toString(16)\n}\n\n/**\n * Converts a hexadecimal string to a bigint\n *\n * @param hexStr\n *\n * @returns a bigint\n */\nexport function hexToBigint (hexStr: string): bigint {\n  return BigInt('0x' + hexStr)\n}\n\n/**\n * Converts a non-negative bigint representing a binary array of utf-8 encoded text to a string of utf-8 text\n *\n * @param a - A non-negative bigint representing a binary array of utf-8 encoded text.\n *\n * @returns a string text with utf-8 encoding\n *\n * @throws {RangeError}\n * Thrown if a < 0.\n */\nexport function bigintToText (a: bigint): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return bufToText(hexToBuf(a.toString(16)))\n}\n\n/**\n * Converts a utf-8 string to a bigint (from its binary representaion)\n *\n * @param text - A string text with utf-8 encoding\n *\n * @returns a bigint representing a binary array of the input utf-8 encoded text\n */\nexport function textToBigint (text: string): bigint {\n  return hexToBigint(bufToHex(textToBuf(text)))\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (in Node.js) containing utf-8 encoded text to a string of utf-8 text\n *\n * @param buf - A buffer containing utf-8 encoded text\n *\n * @returns a string text with utf-8 encoding\n */\nexport function bufToText (buf: ArrayBuffer|TypedArray|Buffer): string {\n  if (IS_BROWSER) return new TextDecoder().decode(new Uint8Array(buf))\n  else return Buffer.from(buf).toString()\n}\n\n/**\n * Converts a string of utf-8 encoded text to an ArrayBuffer or a Buffer (default in Node.js)\n *\n * @param str - A string of text (with utf-8 encoding)\n * @param returnArrayBuffer - When invoked in Node.js, it can force the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer containing the utf-8 encoded text\n */\nexport function textToBuf (str: string, returnArrayBuffer: boolean = false): ArrayBuffer|Buffer {\n  if (!IS_BROWSER && !returnArrayBuffer) {\n    return Buffer.from(new TextEncoder().encode(str).buffer)\n  }\n  return new TextEncoder().encode(str).buffer\n}\n\n/**\n * Returns the hexadecimal representation of a buffer.\n *\n * @param buf\n *\n * @returns a string with a hexadecimal representation of the input buffer\n */\nexport function bufToHex (buf: ArrayBuffer|TypedArray|Buffer): string {\n  if (IS_BROWSER) {\n    let s = ''\n    const h = '0123456789abcdef'\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    else buf = new Uint8Array(buf);\n\n    (buf as Uint8Array).forEach((v) => {\n      s += h[v >> 4] + h[v & 15]\n    })\n\n    return s\n  } else {\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    return Buffer.from(buf).toString('hex')\n  }\n}\n\n/**\n * Converts a hexadecimal string to a buffer\n *\n * @param hexStr - A string representing a number with hexadecimal notation\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns An ArrayBuffer or a Buffer\n *\n * @throws {RangeError}\n * Thrown if hexStr is undefined or not a hexadecimal.\n */\nexport function hexToBuf (hexStr: string, returnArrayBuffer: boolean = false): ArrayBuffer|Buffer {\n  if (hexStr === undefined) {\n    throw RangeError('hexStr cannot undefined')\n  }\n  const hexMatch = hexStr.match(/^(0x)?([\\da-fA-F]+)$/)\n  if (hexMatch == null) {\n    throw RangeError('hexStr must be a hexadecimal string, e.g. \\'0x124fe3a\\' or \\'0214f1b2\\'')\n  }\n  let hex = hexMatch[2]\n  hex = (hex.length % 2 === 0) ? hex : '0' + hex\n  if (IS_BROWSER) {\n    return Uint8Array.from(hex.match(/[\\da-fA-F]{2}/g)!.map((h) => { // eslint-disable-line\n      return parseInt(h, 16)\n    })).buffer\n  } else {\n    const b = Buffer.from(hex, 'hex')\n    if (!returnArrayBuffer) return b\n    else return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength)\n  }\n}\n\n/**\n * Converts an arbitrary-size non-negative bigint to a base64 string\n * @param a - a non negative bigint\n * @param urlsafe - if true Base64 URL encoding is used ('+' and '/' are replaced by '-', '_')\n * @param padding - if false, padding (trailing '=') is removed\n * @returns a base64 representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\nexport function bigintToBase64 (a: bigint, urlsafe: boolean = false, padding: boolean = true): string {\n  return b64.encode(bigintToBuf(a), urlsafe, padding)\n}\n\n/**\n * Converts a base64 string to bigint.\n * @param a base64 string. It accepts standard and URL-safe base64 with and without padding\n * @returns a bigint\n */\nexport function base64ToBigint (a: string): bigint {\n  return bufToBigint(b64.decode(a) as Uint8Array)\n}\n","export default function _classPrivateFieldBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n\n  return receiver;\n}","var id = 0;\nexport default function _classPrivateFieldKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}","/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _255n = BigInt(255);\nconst CURVE_ORDER = _2n ** BigInt(252) + BigInt('27742317777372353535851937790883648493');\nconst CURVE = {\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: _2n ** _255n - BigInt(19),\n    l: CURVE_ORDER,\n    n: CURVE_ORDER,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n};\nexport { CURVE };\nconst MAX_256B = _2n ** BigInt(256);\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(_2n * mod(Z1 ** _2n));\n        const D = mod(a * A);\n        const E = mod(mod((X1 + Y1) ** _2n) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.ZERO;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2 ** _2n));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= MAX_256B)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexport { ExtendedPoint, RistrettoPoint, Point, Signature };\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & (_2n ** _255n - _1n));\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nasync function sha512ModqLE(...args) {\n    const hash = await utils.sha512(concatBytes(...args));\n    const value = bytesToNumberLE(hash);\n    return mod(value, CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nasync function getExtendedPublicKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, MAX_256B))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    const hashed = await utils.sha512(key);\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = mod(bytesToNumberLE(head), CURVE.l);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nexport async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nexport async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = await sha512ModqLE(prefix, message);\n    const R = Point.BASE.multiply(r);\n    const k = await sha512ModqLE(R.toRawBytes(), pointBytes, message);\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nexport async function verify(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    const k = await sha512ModqLE(r.toRawBytes(), publicKey.toRawBytes(), message);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexport async function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        x_3 = mod((DA + CB) ** _2n);\n        z_3 = mod(x_1 * (DA - CB) ** _2n);\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexport const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    bytesToHex,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumberLE(hash), CURVE.l);\n        if (num === _0n || num === _1n)\n            throw new Error('Invalid private key');\n        return num;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (message) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n};\n","import { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        const { view, buffer, blockLen, finished } = this;\n        if (finished)\n            throw new Error('digest() was already called');\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array) || out.length < this.outputLen)\n            throw new Error('_Sha2: Invalid output buffer');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // NOTE: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64bit of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n","export const crypto = {\n    node: undefined,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = wrapConstructor(() => new SHA256());\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianess.\n// So, just to be sure not to corrupt anything.\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nexport function bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte))\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// Currently avoid insertion of polyfills with packers (browserify/webpack/etc)\n// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here\nexport const nextTick = (() => {\n    const nodeRequire = typeof module !== 'undefined' &&\n        typeof module.require === 'function' &&\n        module.require.bind(module);\n    try {\n        if (nodeRequire) {\n            const { setImmediate } = nodeRequire('timers');\n            return () => new Promise((resolve) => setImmediate(resolve));\n        }\n    }\n    catch (e) { }\n    return () => new Promise((resolve) => setTimeout(resolve, 0));\n})();\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexport function assertBool(b) {\n    if (typeof b !== 'boolean') {\n        throw new Error(`Expected boolean, not ${b}`);\n    }\n}\nexport function assertBytes(bytes, ...lengths) {\n    if (bytes instanceof Uint8Array && (!lengths.length || lengths.includes(bytes.length))) {\n        return;\n    }\n    throw new TypeError(`Expected ${lengths} bytes, not ${typeof bytes} with length=${bytes.length}`);\n}\nexport function assertHash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    assertNumber(hash.outputLen);\n    assertNumber(hash.blockLen);\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nexport function checkOpts(def, _opts) {\n    if (_opts !== undefined && (typeof _opts !== 'object' || !isPlainObject(_opts)))\n        throw new TypeError('Options should be object or undefined');\n    const opts = Object.assign(def, _opts);\n    return opts;\n}\nexport function wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto.web) {\n        return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto.node) {\n        return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\n","/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn’t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n"],"names":["hexToBigint","hexStr","BigInt","_classPrivateFieldBase","receiver","privateKey","Object","prototype","hasOwnProperty","call","TypeError","id","_classPrivateFieldKey","name","_0n","_1n","_2n","_255n","CURVE_ORDER","CURVE","a","d","P","l","n","h","Gx","Gy","MAX_256B","SQRT_M1","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","ExtendedPoint","constructor","x","y","z","t","this","p","Point","equals","ZERO","mod","points","toInv","nums","tmp","Array","length","inverted","invert","reduce","acc","num","i","reduceRight","invertBatch","map","toAffine","toAffineBatch","fromAffine","other","assertExtPoint","X1","Y1","Z1","X2","Y2","Z2","X1Z2","X2Z1","Y1Z2","Y2Z1","negate","double","A","B","C","D","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","normalizeZ","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","multiply","scalar","normalizeScalar","multiplyUnsafe","P0","isSmallOrder","isTorsionFree","invZ","ax","ay","fromRistrettoBytes","legacyRist","toRistrettoBytes","fromRistrettoHash","assertRstPoint","RistrettoPoint","ep","r0","r","Ns","c","isValid","Ns_D_is_sq","value","s","uvRatio","s_","edIsNegative","Nt","s2","W0","W1","W2","W3","hex","r1","bytes255ToNumberLE","ensureBytes","slice","R1","calcElligatorRistrettoMap","r2","R2","emsg","b1","b2","equalBytes","numberTo32BytesLE","u1","u2","u1_2","u2_2","v","I","invertSqrt","Dx","Dy","toRawBytes","invsqrt","D1","D2","zInv","_x","_y","toHex","bytesToHex","toString","b","one","two","WeakMap","_setWindowSize","delete","strict","normed","bytesToNumberLE","y2","u","isXOdd","getExtendedPublicKey","point","bytes","toX25519","Signature","assertValidity","fromHex","u8","Uint8Array","concatBytes","arrays","every","arr","result","pad","hexes","from","padStart","uint8a","hexToBytes","array","j","hexByte","byte","parseInt","isNaN","numberTo32BytesBE","reverse","res","number","modulo","q","m","gcd","pow2","power","pow_2_252_3","_5n","_10n","_20n","_40n","_80n","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","v7","vx2","root1","root2","useRoot1","useRoot2","noRoot","async","sha512ModqLE","hash","utils","sha512","expectedLength","max","isSafeInteger","adjustBytes25519","key","hashed","head","prefix","pointBytes","verify","sig","message","publicKey","SB","k","kA","crypto","node","nodeCrypto","web","self","undefined","TORSION_SUBGROUP","hashToPrivateScalar","randomBytes","bytesLength","getRandomValues","buffer","randomPrivateKey","subtle","digest","createHash","update","precompute","SHA2","Hash","blockLen","outputLen","padOffset","isLE","super","finished","pos","destroyed","view","createView","data","len","toBytes","take","min","subarray","process","dataView","roundClean","digestInto","out","fill","byteOffset","setBigUint64","_32n","_u32_max","wh","wl","setUint32","oview","forEach","destroy","_cloneInto","to","Maj","SHA256_K","Uint32Array","IV","SHA256_W","SHA256","getUint32","W15","s0","rotr","s1","sha256","wrapConstructor","DataView","byteLength","word","shift","nodeRequire","module","require","bind","setImmediate","Promise","resolve","e","str","TextEncoder","encode","utf8ToBytes","clone","hashConstructor","hashC","create","proxyMarker","Symbol","createEndpoint","releaseProxy","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","createProxy","target","serialized","isError","stack","assign","addEventListener","callback","ev","type","path","argumentList","fromWireValue","returnValue","parent","prop","rawValue","apply","proxy","transfer","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","endpoint","isMessagePort","close","throwIfProxyReleased","isReleased","isProxyReleased","Proxy","_target","requestResponseMessage","_thisArg","rawArgumentList","last","processArguments","construct","processed","concat","transferCache","transfers","handler","serializedValue","msg","floor","random","MAX_SAFE_INTEGER","join"],"sourceRoot":""}