{"version":3,"file":"static/js/783.cab12217.chunk.js","mappings":"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","sources":["../node_modules/bigint-conversion/src/ts/index.ts","../node_modules/@noble/ed25519/lib/esm/index.js","../node_modules/@noble/hashes/esm/_sha2.js","../node_modules/@noble/hashes/esm/cryptoBrowser.js","../node_modules/@noble/hashes/esm/sha256.js","../node_modules/@noble/hashes/esm/utils.js","../node_modules/comlink/src/comlink.ts"],"sourcesContent":["/**\n * Conversions from/to bingint to TypedArray/Buffer, hex\n *\n * @remarks\n * This module runs perfectly in node.js and browsers\n *\n * @packageDocumentation\n */\n\nimport * as b64 from '@juanelas/base64'\n\n/**\n * A TypedArray object describes an array-like view of an underlying binary data buffer.\n */\nexport type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array\n\n/**\n * Converts an arbitrary-size non-negative bigint to an ArrayBuffer or a Buffer (default for Node.js)\n *\n * @param a\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer with a binary representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0.\n */\nexport function bigintToBuf (a: bigint, returnArrayBuffer: boolean = false): ArrayBuffer|Buffer {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return hexToBuf(bigintToHex(a), returnArrayBuffer)\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (node.js) to a bigint\n * @param buf\n * @returns a bigint\n */\nexport function bufToBigint (buf: ArrayBuffer|TypedArray|Buffer): bigint {\n  let bits = 8n\n  if (ArrayBuffer.isView(buf)) bits = BigInt(buf.BYTES_PER_ELEMENT * 8)\n  else buf = new Uint8Array(buf)\n\n  let ret = 0n\n  for (const i of (buf as TypedArray|Buffer).values()) {\n    const bi = BigInt(i)\n    ret = (ret << bits) + bi\n  }\n  return ret\n}\n\n/**\n * Converts a non-negative bigint to a hexadecimal string\n * @param a - a non negative bigint\n * @returns hexadecimal representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\nexport function bigintToHex (a: bigint): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return a.toString(16)\n}\n\n/**\n * Converts a hexadecimal string to a bigint\n *\n * @param hexStr\n *\n * @returns a bigint\n */\nexport function hexToBigint (hexStr: string): bigint {\n  return BigInt('0x' + hexStr)\n}\n\n/**\n * Converts a non-negative bigint representing a binary array of utf-8 encoded text to a string of utf-8 text\n *\n * @param a - A non-negative bigint representing a binary array of utf-8 encoded text.\n *\n * @returns a string text with utf-8 encoding\n *\n * @throws {RangeError}\n * Thrown if a < 0.\n */\nexport function bigintToText (a: bigint): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return bufToText(hexToBuf(a.toString(16)))\n}\n\n/**\n * Converts a utf-8 string to a bigint (from its binary representaion)\n *\n * @param text - A string text with utf-8 encoding\n *\n * @returns a bigint representing a binary array of the input utf-8 encoded text\n */\nexport function textToBigint (text: string): bigint {\n  return hexToBigint(bufToHex(textToBuf(text)))\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (in Node.js) containing utf-8 encoded text to a string of utf-8 text\n *\n * @param buf - A buffer containing utf-8 encoded text\n *\n * @returns a string text with utf-8 encoding\n */\nexport function bufToText (buf: ArrayBuffer|TypedArray|Buffer): string {\n  if (IS_BROWSER) return new TextDecoder().decode(new Uint8Array(buf))\n  else return Buffer.from(buf).toString()\n}\n\n/**\n * Converts a string of utf-8 encoded text to an ArrayBuffer or a Buffer (default in Node.js)\n *\n * @param str - A string of text (with utf-8 encoding)\n * @param returnArrayBuffer - When invoked in Node.js, it can force the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer containing the utf-8 encoded text\n */\nexport function textToBuf (str: string, returnArrayBuffer: boolean = false): ArrayBuffer|Buffer {\n  if (!IS_BROWSER && !returnArrayBuffer) {\n    return Buffer.from(new TextEncoder().encode(str).buffer)\n  }\n  return new TextEncoder().encode(str).buffer\n}\n\n/**\n * Returns the hexadecimal representation of a buffer.\n *\n * @param buf\n *\n * @returns a string with a hexadecimal representation of the input buffer\n */\nexport function bufToHex (buf: ArrayBuffer|TypedArray|Buffer): string {\n  if (IS_BROWSER) {\n    let s = ''\n    const h = '0123456789abcdef'\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    else buf = new Uint8Array(buf);\n\n    (buf as Uint8Array).forEach((v) => {\n      s += h[v >> 4] + h[v & 15]\n    })\n\n    return s\n  } else {\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    return Buffer.from(buf).toString('hex')\n  }\n}\n\n/**\n * Converts a hexadecimal string to a buffer\n *\n * @param hexStr - A string representing a number with hexadecimal notation\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns An ArrayBuffer or a Buffer\n *\n * @throws {RangeError}\n * Thrown if hexStr is undefined or not a hexadecimal.\n */\nexport function hexToBuf (hexStr: string, returnArrayBuffer: boolean = false): ArrayBuffer|Buffer {\n  if (hexStr === undefined) {\n    throw RangeError('hexStr cannot undefined')\n  }\n  const hexMatch = hexStr.match(/^(0x)?([\\da-fA-F]+)$/)\n  if (hexMatch == null) {\n    throw RangeError('hexStr must be a hexadecimal string, e.g. \\'0x124fe3a\\' or \\'0214f1b2\\'')\n  }\n  let hex = hexMatch[2]\n  hex = (hex.length % 2 === 0) ? hex : '0' + hex\n  if (IS_BROWSER) {\n    return Uint8Array.from(hex.match(/[\\da-fA-F]{2}/g)!.map((h) => { // eslint-disable-line\n      return parseInt(h, 16)\n    })).buffer\n  } else {\n    const b = Buffer.from(hex, 'hex')\n    if (!returnArrayBuffer) return b\n    else return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength)\n  }\n}\n\n/**\n * Converts an arbitrary-size non-negative bigint to a base64 string\n * @param a - a non negative bigint\n * @param urlsafe - if true Base64 URL encoding is used ('+' and '/' are replaced by '-', '_')\n * @param padding - if false, padding (trailing '=') is removed\n * @returns a base64 representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\nexport function bigintToBase64 (a: bigint, urlsafe: boolean = false, padding: boolean = true): string {\n  return b64.encode(bigintToBuf(a), urlsafe, padding)\n}\n\n/**\n * Converts a base64 string to bigint.\n * @param a base64 string. It accepts standard and URL-safe base64 with and without padding\n * @returns a bigint\n */\nexport function base64ToBigint (a: string): bigint {\n  return bufToBigint(b64.decode(a) as Uint8Array)\n}\n","/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _255n = BigInt(255);\nconst CURVE_ORDER = _2n ** BigInt(252) + BigInt('27742317777372353535851937790883648493');\nconst CURVE = {\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: _2n ** _255n - BigInt(19),\n    l: CURVE_ORDER,\n    n: CURVE_ORDER,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n};\nexport { CURVE };\nconst MAX_256B = _2n ** BigInt(256);\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    static fromRistrettoHash(hash) {\n        hash = ensureBytes(hash, 64);\n        const r1 = bytes255ToNumberLE(hash.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hash.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return R1.add(R2);\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static fromRistrettoBytes(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'ExtendedPoint.fromRistrettoBytes: Cannot convert bytes to Ristretto Point';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberToBytesLEPadded(s, 32), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new ExtendedPoint(x, y, _1n, t);\n    }\n    toRistrettoBytes() {\n        let { x, y, z, t } = this;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2 ** _2n));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberToBytesLEPadded(s, 32);\n    }\n    equals(other) {\n        const a = this;\n        const b = other;\n        return mod(a.t * b.z) === mod(b.t * a.z);\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const { a } = CURVE;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(_2n * Z1 ** _2n);\n        const D = mod(a * A);\n        const E = mod((X1 + Y1) ** _2n - A - B);\n        const G = mod(D + B);\n        const F = mod(G - C);\n        const H = mod(D - B);\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        const X1 = this.x;\n        const Y1 = this.y;\n        const Z1 = this.z;\n        const T1 = this.t;\n        const X2 = other.x;\n        const Y2 = other.y;\n        const Z2 = other.z;\n        const T2 = other.t;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n) {\n            return this.double();\n        }\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = mod(D + C);\n        const G = mod(B + A);\n        const H = mod(D - C);\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.n);\n        const P0 = ExtendedPoint.ZERO;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    precomputeWindow(W) {\n        const windows = 256 / W + 1;\n        let points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.ZERO;\n        const windows = 256 / W + 1;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return [p, f];\n    }\n    multiply(scalar, affinePoint) {\n        const n = normalizeScalar(scalar, CURVE.n);\n        return ExtendedPoint.normalizeZ(this.wNAF(n, affinePoint))[0];\n    }\n    multiplyForVerification(scalar) {\n        const n = normalizeScalar(scalar, CURVE.n, false);\n        return ExtendedPoint.normalizeZ(this.wNAF(n))[0];\n    }\n    toAffine(invZ = invert(this.z)) {\n        const x = mod(this.x * invZ);\n        const y = mod(this.y * invZ);\n        return new Point(x, y);\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if ((strict && y >= P) || (!strict && y >= MAX_256B)) {\n            throw new Error('Point.fromHex expects hex <= Fp');\n        }\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberToBytesLEPadded(this.y, 32);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberToBytesLEPadded(u, 32);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s, strict = true) {\n        this.r = r;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        this.s = normalizeScalar(s, CURVE.n, strict);\n    }\n    static fromHex(hex, strict = true) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), strict);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s, strict);\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberToBytesLEPadded(this.s, 32), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexport { ExtendedPoint, Point, Signature };\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberToBytesBEPadded(num, length) {\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberToBytesLEPadded(num, length) {\n    return numberToBytesBEPadded(num, length).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & (_2n ** _255n - _1n));\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, modulo = CURVE.P) {\n    const len = nums.length;\n    const scratch = new Array(len);\n    let acc = _1n;\n    for (let i = 0; i < len; i++) {\n        if (nums[i] === _0n)\n            continue;\n        scratch[i] = acc;\n        acc = mod(acc * nums[i], modulo);\n    }\n    acc = invert(acc, modulo);\n    for (let i = len - 1; i >= 0; i--) {\n        if (nums[i] === _0n)\n            continue;\n        let tmp = mod(acc * nums[i], modulo);\n        nums[i] = mod(acc * scratch[i], modulo);\n        acc = tmp;\n    }\n    return nums;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nasync function sha512ModnLE(...args) {\n    const messageArray = concatBytes(...args);\n    const hash = await utils.sha512(messageArray);\n    const value = bytesToNumberLE(hash);\n    return mod(value, CURVE.n);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'bigint') {\n        if (strict) {\n            if (_0n < num && num < max)\n                return num;\n        }\n        else {\n            if (_0n <= num && num < MAX_256B)\n                return num;\n        }\n    }\n    if (typeof num === 'number' && Number.isSafeInteger(num)) {\n        if (strict) {\n            if (0 < num)\n                return BigInt(num);\n        }\n        else {\n            if (0 <= num)\n                return BigInt(num);\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nasync function getExtendedPublicKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberToBytesBEPadded(normalizeScalar(key, MAX_256B), 32)\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    const hashed = await utils.sha512(key);\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = mod(bytesToNumberLE(head), CURVE.n);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nexport async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nexport async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = await sha512ModnLE(prefix, message);\n    const R = Point.BASE.multiply(r);\n    const k = await sha512ModnLE(R.toRawBytes(), pointBytes, message);\n    const S = mod(r + k * scalar, CURVE.n);\n    return new Signature(R, S).toRawBytes();\n}\nexport async function verify(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    if (!(sig instanceof Signature))\n        sig = Signature.fromHex(sig, false);\n    const SB = ExtendedPoint.BASE.multiplyForVerification(sig.s);\n    const k = await sha512ModnLE(sig.r.toRawBytes(), publicKey.toRawBytes(), message);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(sig.r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexport async function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        x_3 = mod((DA + CB) ** _2n);\n        z_3 = mod(x_1 * (DA - CB) ** _2n);\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberToBytesLEPadded(mod(u, CURVE.P), 32);\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexport const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    bytesToHex,\n    getExtendedPublicKey,\n    mod,\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (message) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n};\n","import { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        const { view, buffer, blockLen, finished } = this;\n        if (finished)\n            throw new Error('digest() was already called');\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array) || out.length < this.outputLen)\n            throw new Error('_Sha2: Invalid output buffer');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // NOTE: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64bit of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n","export const crypto = {\n    node: undefined,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = wrapConstructor(() => new SHA256());\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianess.\n// So, just to be sure not to corrupt anything.\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nexport function bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte))\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// Currently avoid insertion of polyfills with packers (browserify/webpack/etc)\n// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here\nexport const nextTick = (() => {\n    const nodeRequire = typeof module !== 'undefined' &&\n        typeof module.require === 'function' &&\n        module.require.bind(module);\n    try {\n        if (nodeRequire) {\n            const { setImmediate } = nodeRequire('timers');\n            return () => new Promise((resolve) => setImmediate(resolve));\n        }\n    }\n    catch (e) { }\n    return () => new Promise((resolve) => setTimeout(resolve, 0));\n})();\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexport function assertBool(b) {\n    if (typeof b !== 'boolean') {\n        throw new Error(`Expected boolean, not ${b}`);\n    }\n}\nexport function assertBytes(bytes, ...lengths) {\n    if (bytes instanceof Uint8Array && (!lengths.length || lengths.includes(bytes.length))) {\n        return;\n    }\n    throw new TypeError(`Expected ${lengths} bytes, not ${typeof bytes} with length=${bytes.length}`);\n}\nexport function assertHash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    assertNumber(hash.outputLen);\n    assertNumber(hash.blockLen);\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nexport function checkOpts(def, _opts) {\n    if (_opts !== undefined && (typeof _opts !== 'object' || !isPlainObject(_opts)))\n        throw new TypeError('Options should be object or undefined');\n    const opts = Object.assign(def, _opts);\n    return opts;\n}\nexport function wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto.web) {\n        return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto.node) {\n        return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\n","/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nexport function expose(obj: any, ep: Endpoint = self as any) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n        }\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          return requestResponseMessage(ep, {\n            type: MessageType.RELEASE,\n            path: path.map((p) => p.toString()),\n          }).then(() => {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously \\_()_/\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didnt happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = self,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n"],"names":["hexToBigint","hexStr","BigInt","_0n","_1n","_2n","_255n","CURVE_ORDER","CURVE","a","d","P","l","n","h","Gx","Gy","MAX_256B","SQRT_M1","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","ExtendedPoint","constructor","x","y","z","t","this","p","Point","TypeError","equals","ZERO","mod","points","toInv","nums","modulo","len","length","scratch","Array","acc","i","invert","tmp","invertBatch","map","toAffine","toAffineBatch","fromAffine","hash","r1","bytes255ToNumberLE","ensureBytes","slice","R1","calcElligatorRistrettoMap","r2","R2","add","r0","r","Ns","c","D","isValid","Ns_D_is_sq","value","s","uvRatio","s_","edIsNegative","Nt","s2","W0","W1","W2","W3","hex","emsg","b1","b2","equalBytes","numberToBytesLEPadded","Error","u1","u2","u1_2","u2_2","v","I","invertSqrt","Dx","Dy","toRistrettoBytes","invsqrt","D1","D2","zInv","_x","_y","other","b","negate","double","X1","Y1","Z1","A","B","C","E","G","F","H","X3","Y3","T3","Z3","T1","X2","Y2","Z2","T2","subtract","multiplyUnsafe","scalar","normalizeScalar","P0","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","get","normalizeZ","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","multiply","multiplyForVerification","invZ","WeakMap","_setWindowSize","delete","strict","normed","bytesToNumberLE","y2","u","isXOdd","privateKey","getExtendedPublicKey","point","toRawBytes","bytes","toHex","bytesToHex","toX25519","Signature","fromHex","u8","Uint8Array","concatBytes","arrays","every","reduce","arr","result","pad","hexes","from","toString","padStart","uint8a","hexToBytes","array","j","hexByte","byte","parseInt","isNaN","numberToBytesBEPadded","num","reverse","res","number","q","m","gcd","pow2","power","pow_2_252_3","_5n","_10n","_20n","_40n","_80n","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","v7","vx2","root1","root2","useRoot1","useRoot2","noRoot","async","sha512ModnLE","messageArray","utils","sha512","expectedLength","max","isSafeInteger","adjustBytes25519","key","hashed","head","prefix","pointBytes","verify","sig","message","publicKey","SB","k","kA","crypto","node","nodeCrypto","web","self","undefined","TORSION_SUBGROUP","randomBytes","bytesLength","getRandomValues","buffer","randomPrivateKey","subtle","digest","createHash","update","precompute","SHA2","Hash","blockLen","outputLen","padOffset","isLE","super","finished","pos","destroyed","view","createView","data","toBytes","take","min","subarray","process","dataView","roundClean","digestInto","out","fill","byteOffset","setBigUint64","_32n","_u32_max","wh","wl","setUint32","oview","forEach","destroy","_cloneInto","to","Maj","SHA256_K","Uint32Array","IV","SHA256_W","SHA256","getUint32","W15","s0","rotr","s1","sha256","wrapConstructor","DataView","byteLength","word","shift","nodeRequire","module","require","bind","setImmediate","Promise","resolve","e","str","TextEncoder","encode","utf8ToBytes","clone","hashConstructor","hashC","create","proxyMarker","Symbol","createEndpoint","releaseProxy","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","createProxy","target","serialized","isError","name","stack","Object","assign","ep","addEventListener","callback","ev","id","type","path","argumentList","fromWireValue","returnValue","parent","prop","rawValue","apply","proxy","transfer","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","endpoint","isMessagePort","close","throwIfProxyReleased","isReleased","isProxyReleased","Proxy","_target","requestResponseMessage","_thisArg","rawArgumentList","last","processArguments","construct","processed","prototype","concat","transferCache","transfers","handler","serializedValue","msg","floor","random","MAX_SAFE_INTEGER","join"],"sourceRoot":""}