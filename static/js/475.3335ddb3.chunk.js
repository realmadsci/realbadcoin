(()=>{var t={2455:(t,e,i)=>{"use strict";var s=i(6274),n=i(9359),a=i(1555),c=i(8238),r=i(1865),o=i(8677),l=i(8578);class h{constructor(){this.type="coin_transfer",this.destination=null,this.amount=0}static coerce(t){let{type:e,destination:i,amount:s}=t;try{if("coin_transfer"!==e)return null;let t=new h;return t.type=e,t.destination=i,t.amount=s,t}catch{return null}}isValid(){try{return"coin_transfer"===this.type&&32===(0,o.nr)(this.destination).length&&Number.isFinite(this.amount)&&this.amount>0}catch{return!1}}}class u{constructor(){this.type="nft_mint",this.nftData=null,this.nftId=null}hash(){return(0,o.ci)((0,r.J)(JSON.stringify(this.nftData)))}static coerce(t){let{type:e,nftData:i,nftId:s}=t;try{if("nft_mint"!==e)return null;let t=new u;return t.type=e,t.nftData=i,t.nftId=s,t}catch{return null}}isValid(){try{return"nft_mint"===this.type&&32===(0,o.nr)(this.nftId).length&&this.nftId===this.hash()&&null!==this.nftData&&JSON.stringify(this.nftData).length>0}catch{return!1}}}class f{constructor(){this.type="nft_transfer",this.nftId=null,this.nftNonce=0,this.destination=null}static coerce(t){let{type:e,nftId:i,nftNonce:s,destination:n}=t;try{if("nft_transfer"!==e)return null;let t=new f;return t.type=e,t.nftId=i,t.nftNonce=s,t.destination=n,t}catch{return null}}isValid(){try{return"nft_transfer"===this.type&&Number.isInteger(this.nftNonce)&&32===(0,o.nr)(this.nftId).length&&32===(0,o.nr)(this.destination).length}catch{return!1}}}class d{constructor(){this.source=null,this.sourceNonce=0,this.timestamp=null,this.transactionFee=0,this.txData=null,this.txId=null,this.signature=null}hash(){let t=JSON.stringify([this.source,this.sourceNonce,this.timestamp,this.transactionFee,this.txData]);return(0,o.ci)((0,r.J)(t))}static coerce(t){let{source:e,sourceNonce:i,timestamp:s,transactionFee:n,txData:a,txId:c,signature:r}=t;try{let t=new d;return t.source=e,t.sourceNonce=i,t.timestamp=new Date(s),t.transactionFee=n,t.txId=c,t.signature=r,t.txData=h.coerce(a)||u.coerce(a)||f.coerce(a),t}catch{return null}}async isValid(){try{return 32===(0,o.nr)(this.source).length&&Number.isInteger(this.sourceNonce)&&this.timestamp instanceof Date&&!isNaN(this.timestamp.getTime())&&Number.isFinite(this.transactionFee)&&this.transactionFee>=0&&this.txData.isValid()&&32===(0,o.nr)(this.txId).length&&this.hash()===this.txId&&64===(0,o.nr)(this.signature).length&&await c.T(this.signature,this.txId,this.source)}catch{return!1}}async seal(t){this.source=await t.getPubKeyHex(),this.timestamp=new Date,this.txId=this.hash(),this.signature=(0,o.ci)(await t.sign(this.txId))}}class k{constructor(){this.prevHash="00".repeat(32),this.blockHeight=0,this.timestamp=null,this.transactions=[],this.miningReward=100,this.rewardDestination=null,this.difficulty=65536,this.nonce=0}get hash(){let t=JSON.stringify(this);return(0,o.ci)((0,r.J)(t))}static difficultyMetric(t){return(1n<<256n)/(0,l.gO)(t)}isSealed(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:65536,e=Math.max(t,this.difficulty),i=(1n<<256n)/BigInt(e);return(0,l.gO)(this.hash)<i}tryToSeal(t){let e=(1n<<256n)/BigInt(this.difficulty);this.timestamp=new Date;for(let i=0;i<t;i++){let t=this.hash;if((0,l.gO)(t)<e)return this.isSealed(this.difficulty);this.nonce++}return!1}static coerce(t){let{prevHash:e,blockHeight:i,timestamp:s,transactions:n,miningReward:a,rewardDestination:c,difficulty:r,nonce:o}=t;try{let t=new k;return t.prevHash=e,t.blockHeight=i,t.timestamp=new Date(s),t.transactions=n.map((t=>d.coerce(t))),t.miningReward=a,t.rewardDestination=c,t.difficulty=r,t.nonce=o,t}catch(l){return console.error(l),null}}async isValid(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:65536;try{return this.isSealed(t)&&32===(0,o.nr)(this.prevHash).length&&Number.isInteger(this.blockHeight)&&this.blockHeight>=0&&(this.blockHeight>0||this.prevHash==="00".repeat(32))&&this.timestamp instanceof Date&&!isNaN(this.timestamp.getTime())&&Array.isArray(this.transactions)&&async function(t,e){for(let i of t)if(!await e(i))return!1;return!0}(this.transactions,(async t=>t instanceof d&&await t.isValid()))&&Number.isFinite(this.miningReward)&&this.miningReward>=0&&32===(0,o.nr)(this.rewardDestination).length}catch{return!1}}}var p=i(7465);class g{constructor(){this.balance=0,this.nonce=0}static coerce(t){let{balance:e,nonce:i}=t,s=new g;return s.balance=e,s.nonce=i,s}}class y{constructor(){this.owner=null,this.nonce=0}static coerce(t){let{owner:e,nonce:i}=t,s=new y;return s.owner=e,s.nonce=i,s}}class b{constructor(t,e){this.message="",this.transaction=null,this.message=t,this.transaction=e}toString(){return"Bad Transaction:\n"+this.message+"\n"+this.transaction.toString()}}class m{constructor(){this.accounts={},this.nfts={},this.transactionFees=0,this.lastBlockHash="00".repeat(32),this.lastBlockHeight=-1,this.nextBlockDifficulty=2e6,this.lastBlockTimestamp=null,this.totalDifficulty=0n}static coerce(t){let{accounts:e,nfts:i,transactionFees:s,lastBlockHash:n,lastBlockHeight:a,nextBlockDifficulty:c,lastBlockTimestamp:r,totalDifficulty:o}=t,l=new m;return Object.keys(e).forEach((t=>{l.accounts[t]=g.coerce(e[t])})),Object.keys(i).forEach((t=>{l.nfts[t]=y.coerce(i[t])})),l.transactionFees=s,l.lastBlockHash=n,l.lastBlockHeight=a,l.nextBlockDifficulty=c,l.lastBlockTimestamp=r,l.totalDifficulty=o,l}clone(){let t=Object.assign({},this);return t.totalDifficulty=(0,l.ow)(t.totalDifficulty),t=m.coerce(JSON.parse(JSON.stringify(t))),t.totalDifficulty=(0,l.gO)(t.totalDifficulty),t}tryTransaction(t){if(t.txData instanceof h){if(!(t.source in this.accounts))throw new b("Account tried to send coins before it existed",t);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new b("Incorrect nonce",t);if(t.txData.amount+t.transactionFee>this.accounts[t.source].balance)throw new b("Insufficient balance",t);this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.txData.amount+t.transactionFee,this.transactionFees+=t.transactionFee,t.txData.destination in this.accounts||(this.accounts[t.txData.destination]=new g),this.accounts[t.txData.destination].balance+=t.txData.amount}else if(t.txData instanceof u){if(t.txData.nftId in this.nfts)throw new b("NFT Mint attempted on already-existing NFT ID",t);if(t.transactionFee>0){if(!(t.source in this.accounts))throw new b("Account tried to pay NFT Mint txFee before it existed",t);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new b("Incorrect nonce for NFT Mint txFee",t);if(t.transactionFee>this.accounts[t.source].balance)throw new b("Insufficient balance for NFT Mint txFee",t)}t.transactionFee>0&&(this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.transactionFee,this.transactionFees+=t.transactionFee);let e=new y;e.nonce=0,e.owner=t.source,this.nfts[t.txData.nftId]=e}else if(t.txData instanceof f){let e=t.txData.nftId;if(!(e in this.nfts))throw new b("NFT Transfer attempted on non-existent NFT ID",t);if(this.nfts[e].owner!==t.source)throw new b("NFT Transfer attempted by non-owner of NFT",t);if(t.txData.nftNonce!==this.nfts[e].nonce+1)throw new b("Incorrect NFT nonce",t);if(t.transactionFee>0){if(!(t.source in this.accounts))throw new b("Account tried to pay NFT Mint txFee before it existed",t);if(t.sourceNonce!==this.accounts[t.source].nonce+1)throw new b("Incorrect nonce for NFT Mint txFee",t);if(t.transactionFee>this.accounts[t.source].balance)throw new b("Insufficient balance for NFT Mint txFee",t)}t.transactionFee>0&&(this.accounts[t.source].nonce++,this.accounts[t.source].balance-=t.transactionFee,this.transactionFees+=t.transactionFee),this.nfts[e].nonce++,this.nfts[e].owner=t.txData.destination}}applyBlock(t){let e=this.clone();if(t.prevHash!==this.lastBlockHash)return null;if(t.blockHeight!==this.lastBlockHeight+1)return null;if(t.timestamp>new Date)return null;if(0!==t.blockHeight&&t.timestamp<this.lastBlockTimestamp)return null;e.lastBlockHash=t.hash,e.lastBlockHeight=t.blockHeight;let i=0===t.blockHeight?0:t.timestamp-this.lastBlockTimestamp;if(e.lastBlockTimestamp=t.timestamp,e.totalDifficulty=this.totalDifficulty+k.difficultyMetric(e.lastBlockHash),t.difficulty<this.nextBlockDifficulty)return null;if(0===t.blockHeight)e.nextBlockDifficulty=this.nextBlockDifficulty;else{let t=i/15e3,s=.01;e.nextBlockDifficulty=Math.round(this.nextBlockDifficulty*(1-s+s/t))}console.log("Target difficulty after block "+e.lastBlockHeight.toString()+" is "+e.nextBlockDifficulty.toString());try{t.transactions.forEach((t=>{e.tryTransaction(t)}))}catch(s){return console.error(s),null}return t.rewardDestination in e.accounts||(e.accounts[t.rewardDestination]=new g),e.accounts[t.rewardDestination].balance+=t.miningReward+e.transactionFees,e.transactionFees=0,e}}class w{constructor(){this._blocks={},this._anticipatedBlocks={},this._readyBlocks=[],this._bestBlock=null,this.minDifficulty=65536,this._updateNotifier=new p.EventEmitter}subscribe(t){this._updateNotifier.addListener("new_block",t)}unsubscribe(t){this._updateNotifier.removeListener("new_block",t)}addBlock(t,e,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.minDifficulty;try{let n=t.hash;if(t instanceof k&&t.isValid(s)&&!(n in this._blocks)){this._blocks[n]={block:t,source:e},0===t.blockHeight||t.prevHash in this._blocks&&"state"in this._blocks[t.prevHash]?this._readyBlocks.push(n):(t.prevHash in this._anticipatedBlocks||(this._anticipatedBlocks[t.prevHash]=[]),this._anticipatedBlocks[t.prevHash].push(n),this._readyBlocks.length&&console.error("Expected _readyBlocks to be empty but there were "+this._readyBlocks.length));for(;this._readyBlocks.length;){let t=this.getBlock(this._readyBlocks.pop()),e=t.hash;0===t.blockHeight?this._blocks[e].state=(new m).applyBlock(t):null===this._blocks[t.prevHash].state?this._blocks[e].state=null:this._blocks[e].state=this._blocks[t.prevHash].state.applyBlock(t),e in this._anticipatedBlocks&&(this._readyBlocks=this._readyBlocks.concat(this._anticipatedBlocks[e]),delete this._anticipatedBlocks[e]);let i=this.getState(e);if(null!==i){let t=this.getState(this._bestBlock);(null===t||i.totalDifficulty>t.totalDifficulty)&&(this._bestBlock=e)}}return this._updateNotifier.emit("new_block",n,i),!0}}catch(n){return console.error(n),!1}}get bestBlockHash(){return this._bestBlock}getBlock(t){return t in this._blocks?this._blocks[t].block:null}getSource(t){return t in this._blocks?this._blocks[t].source:null}getState(t){return t in this._blocks&&"state"in this._blocks[t]?this._blocks[t].state:null}getChain(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=[],s=null!==t&&void 0!==t?t:this.bestBlockHash,n=this.getBlock(s);for(;s!==e&&null!==n&&(i.unshift(s),0!==n.blockHeight);)s=n.prevHash,n=this.getBlock(s);return i}}var B=(0,n.Z)("cache");a.Jj(class{constructor(){Object.defineProperty(this,B,{writable:!0,value:new w})}addBlock(t,e){let i=k.coerce(t);return(0,s.Z)(this,B)[B].addBlock(i,e)}addBlocks(t,e){return t.map(((t,i)=>this.addBlock(t,e)))}getBlockInfo(t){return{block:(0,s.Z)(this,B)[B].getBlock(t),state:(0,s.Z)(this,B)[B].getState(t),source:(0,s.Z)(this,B)[B].getSource(t)}}getBlocks(t){return t.map(((t,e)=>(0,s.Z)(this,B)[B].getBlock(t)))}getChain(t,e){return(0,s.Z)(this,B)[B].getChain(t,e)}get bestBlockHash(){return(0,s.Z)(this,B)[B].bestBlockHash}})},7420:()=>{}},e={};function i(s){var n=e[s];if(void 0!==n)return n.exports;var a=e[s]={exports:{}};return t[s](a,a.exports,i),a.exports}i.m=t,i.x=()=>{var t=i.O(void 0,[974,482],(()=>i(2455)));return t=i.O(t)},(()=>{var t=[];i.O=(e,s,n,a)=>{if(!s){var c=1/0;for(h=0;h<t.length;h++){for(var[s,n,a]=t[h],r=!0,o=0;o<s.length;o++)(!1&a||c>=a)&&Object.keys(i.O).every((t=>i.O[t](s[o])))?s.splice(o--,1):(r=!1,a<c&&(c=a));if(r){t.splice(h--,1);var l=n();void 0!==l&&(e=l)}}return e}a=a||0;for(var h=t.length;h>0&&t[h-1][2]>a;h--)t[h]=t[h-1];t[h]=[s,n,a]}})(),i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.f={},i.e=t=>Promise.all(Object.keys(i.f).reduce(((e,s)=>(i.f[s](t,e),e)),[])),i.u=t=>"static/js/"+t+"."+{482:"d67f4f5e",974:"eeffc38f"}[t]+".chunk.js",i.miniCssF=t=>{},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.p="/",(()=>{var t={475:1};i.f.i=(e,s)=>{t[e]||importScripts(i.p+i.u(e))};var e=self.webpackChunkrealbadcoin=self.webpackChunkrealbadcoin||[],s=e.push.bind(e);e.push=e=>{var[n,a,c]=e;for(var r in a)i.o(a,r)&&(i.m[r]=a[r]);for(c&&c(i);n.length;)t[n.pop()]=1;s(e)}})(),(()=>{var t=i.x;i.x=()=>Promise.all([i.e(974),i.e(482)]).then(t)})();i.x()})();
//# sourceMappingURL=475.3335ddb3.chunk.js.map