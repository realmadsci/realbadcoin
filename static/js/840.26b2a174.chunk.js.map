{"version":3,"file":"static/js/840.26b2a174.chunk.js","mappings":"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","sources":["../node_modules/bigint-conversion/src/ts/index.ts","util/RealBadCoin.tsx","util/MineWorker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["/**\n * Conversions from/to bingint to TypedArray/Buffer, hex\n *\n * @remarks\n * This module runs perfectly in node.js and browsers\n *\n * @packageDocumentation\n */\n\nimport * as b64 from '@juanelas/base64'\n\n/**\n * A TypedArray object describes an array-like view of an underlying binary data buffer.\n */\nexport type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array\n\n/**\n * Converts an arbitrary-size non-negative bigint to an ArrayBuffer or a Buffer (default for Node.js)\n *\n * @param a\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer with a binary representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0.\n */\nexport function bigintToBuf (a: bigint, returnArrayBuffer: boolean = false): ArrayBuffer|Buffer {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return hexToBuf(bigintToHex(a), returnArrayBuffer)\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (node.js) to a bigint\n * @param buf\n * @returns a bigint\n */\nexport function bufToBigint (buf: ArrayBuffer|TypedArray|Buffer): bigint {\n  let bits = 8n\n  if (ArrayBuffer.isView(buf)) bits = BigInt(buf.BYTES_PER_ELEMENT * 8)\n  else buf = new Uint8Array(buf)\n\n  let ret = 0n\n  for (const i of (buf as TypedArray|Buffer).values()) {\n    const bi = BigInt(i)\n    ret = (ret << bits) + bi\n  }\n  return ret\n}\n\n/**\n * Converts a non-negative bigint to a hexadecimal string\n * @param a - a non negative bigint\n * @returns hexadecimal representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\nexport function bigintToHex (a: bigint): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return a.toString(16)\n}\n\n/**\n * Converts a hexadecimal string to a bigint\n *\n * @param hexStr\n *\n * @returns a bigint\n */\nexport function hexToBigint (hexStr: string): bigint {\n  return BigInt('0x' + hexStr)\n}\n\n/**\n * Converts a non-negative bigint representing a binary array of utf-8 encoded text to a string of utf-8 text\n *\n * @param a - A non-negative bigint representing a binary array of utf-8 encoded text.\n *\n * @returns a string text with utf-8 encoding\n *\n * @throws {RangeError}\n * Thrown if a < 0.\n */\nexport function bigintToText (a: bigint): string {\n  if (a < 0) throw RangeError('a should be a non-negative integer. Negative values are not supported')\n  return bufToText(hexToBuf(a.toString(16)))\n}\n\n/**\n * Converts a utf-8 string to a bigint (from its binary representaion)\n *\n * @param text - A string text with utf-8 encoding\n *\n * @returns a bigint representing a binary array of the input utf-8 encoded text\n */\nexport function textToBigint (text: string): bigint {\n  return hexToBigint(bufToHex(textToBuf(text)))\n}\n\n/**\n * Converts an ArrayBuffer, TypedArray or Buffer (in Node.js) containing utf-8 encoded text to a string of utf-8 text\n *\n * @param buf - A buffer containing utf-8 encoded text\n *\n * @returns a string text with utf-8 encoding\n */\nexport function bufToText (buf: ArrayBuffer|TypedArray|Buffer): string {\n  if (IS_BROWSER) return new TextDecoder().decode(new Uint8Array(buf))\n  else return Buffer.from(buf).toString()\n}\n\n/**\n * Converts a string of utf-8 encoded text to an ArrayBuffer or a Buffer (default in Node.js)\n *\n * @param str - A string of text (with utf-8 encoding)\n * @param returnArrayBuffer - When invoked in Node.js, it can force the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns an ArrayBuffer or a Buffer containing the utf-8 encoded text\n */\nexport function textToBuf (str: string, returnArrayBuffer: boolean = false): ArrayBuffer|Buffer {\n  if (!IS_BROWSER && !returnArrayBuffer) {\n    return Buffer.from(new TextEncoder().encode(str).buffer)\n  }\n  return new TextEncoder().encode(str).buffer\n}\n\n/**\n * Returns the hexadecimal representation of a buffer.\n *\n * @param buf\n *\n * @returns a string with a hexadecimal representation of the input buffer\n */\nexport function bufToHex (buf: ArrayBuffer|TypedArray|Buffer): string {\n  if (IS_BROWSER) {\n    let s = ''\n    const h = '0123456789abcdef'\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    else buf = new Uint8Array(buf);\n\n    (buf as Uint8Array).forEach((v) => {\n      s += h[v >> 4] + h[v & 15]\n    })\n\n    return s\n  } else {\n    if (ArrayBuffer.isView(buf)) buf = new Uint8Array(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n    return Buffer.from(buf).toString('hex')\n  }\n}\n\n/**\n * Converts a hexadecimal string to a buffer\n *\n * @param hexStr - A string representing a number with hexadecimal notation\n * @param returnArrayBuffer - In Node.js, it forces the output to be an ArrayBuffer instead of a Buffer.\n *\n * @returns An ArrayBuffer or a Buffer\n *\n * @throws {RangeError}\n * Thrown if hexStr is undefined or not a hexadecimal.\n */\nexport function hexToBuf (hexStr: string, returnArrayBuffer: boolean = false): ArrayBuffer|Buffer {\n  if (hexStr === undefined) {\n    throw RangeError('hexStr cannot undefined')\n  }\n  const hexMatch = hexStr.match(/^(0x)?([\\da-fA-F]+)$/)\n  if (hexMatch == null) {\n    throw RangeError('hexStr must be a hexadecimal string, e.g. \\'0x124fe3a\\' or \\'0214f1b2\\'')\n  }\n  let hex = hexMatch[2]\n  hex = (hex.length % 2 === 0) ? hex : '0' + hex\n  if (IS_BROWSER) {\n    return Uint8Array.from(hex.match(/[\\da-fA-F]{2}/g)!.map((h) => { // eslint-disable-line\n      return parseInt(h, 16)\n    })).buffer\n  } else {\n    const b = Buffer.from(hex, 'hex')\n    if (!returnArrayBuffer) return b\n    else return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength)\n  }\n}\n\n/**\n * Converts an arbitrary-size non-negative bigint to a base64 string\n * @param a - a non negative bigint\n * @param urlsafe - if true Base64 URL encoding is used ('+' and '/' are replaced by '-', '_')\n * @param padding - if false, padding (trailing '=') is removed\n * @returns a base64 representation of the input bigint\n *\n * @throws {RangeError}\n * Thrown if a < 0\n */\nexport function bigintToBase64 (a: bigint, urlsafe: boolean = false, padding: boolean = true): string {\n  return b64.encode(bigintToBuf(a), urlsafe, padding)\n}\n\n/**\n * Converts a base64 string to bigint.\n * @param a base64 string. It accepts standard and URL-safe base64 with and without padding\n * @returns a bigint\n */\nexport function base64ToBigint (a: string): bigint {\n  return bufToBigint(b64.decode(a) as Uint8Array)\n}\n","// Data strucures and accessors for the RealBadCoin crypto currency\r\n\r\nimport * as ed from '@noble/ed25519';\r\nimport { sha256 } from '@noble/hashes/sha256';\r\nimport { bytesToHex, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\r\nimport { hexToBigint } from 'bigint-conversion';\r\n\r\nexport async function asyncEvery(arr, predicate) {\r\n\tfor (let e of arr) {\r\n\t\tif (!await predicate(e)) return false;\r\n\t}\r\n\treturn true;\r\n};\r\n\r\nexport class RealBadCoinTransfer {\r\n    type = \"coin_transfer\";\r\n    destination = null; // Destination account ID (public key)\r\n    amount = 0;         // Amount of RealBadCoin to transfer (floating point number)\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        type,\r\n        destination,\r\n        amount,\r\n    }) {\r\n        try {\r\n            if (type !== \"coin_transfer\") return null;\r\n\r\n            let r = new RealBadCoinTransfer();\r\n            r.type = type;\r\n            r.destination = destination;\r\n            r.amount = amount;\r\n            return r;\r\n        } catch {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check the all fields have correct data types\r\n    isValid() {\r\n        try {\r\n            return (\r\n                this.type === \"coin_transfer\" &&\r\n\r\n                // The destination is a 32-byte hex value\r\n                (hexToBytes(this.destination).length === 32) &&\r\n\r\n                // The amount is a finite positive number\r\n                Number.isFinite(this.amount) &&\r\n                (this.amount > 0)\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// Create a new NFT. The \"source\" account is the owner of the NFT until it is transferred via a RealBadNftTransfer.\r\n// NOTE: These aren't free - like all transactions, you have to pay a miner's fee to make one!\r\nexport class RealBadNftMint {\r\n    type = \"nft_mint\";\r\n    nftData = null;     // Any data we want to \"mint\" as an NFT. Can be a string, and object, whatever...\r\n    nftId = null;       // The ID (hash) of the `nftData` object. Must a globally unique number on the block chain (so nftData must be unique).\r\n\r\n    // Compute the hash (txId) of this object\r\n    hash() {\r\n        return bytesToHex(sha256(JSON.stringify(this.nftData)));\r\n    }\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        type,\r\n        nftData,\r\n        nftId,\r\n    }) {\r\n        try {\r\n            if (type !== \"nft_mint\") return null;\r\n\r\n            let r = new RealBadNftMint();\r\n            r.type = type;\r\n            r.nftData = nftData;\r\n            r.nftId = nftId;\r\n            return r;\r\n        } catch {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check the all fields have correct data types\r\n    isValid() {\r\n        try {\r\n            return (\r\n                this.type === \"nft_mint\" &&\r\n\r\n                // The NFT ID is a 32-byte hex value and it matches the hash\r\n                (hexToBytes(this.nftId).length === 32) &&\r\n                this.nftId === this.hash() &&\r\n\r\n                // The data isn't null and can be turned into a JSON string\r\n                this.nftData !== null &&\r\n                JSON.stringify(this.nftData).length > 0\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\nexport class RealBadNftTransfer {\r\n    type = \"nft_transfer\";\r\n    nftId = null;       // The ID (hash) of the NFT. Must already be minted before it can be transferred.\r\n    nftNonce = 0;       // Incrementing number specifying transfer count for this NFT. Must be sequentually incrementing or the transaction will be ignored.\r\n    destination = null; // Destination account ID (public key) for the new owner of the NFT.\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        type,\r\n        nftId,\r\n        nftNonce,\r\n        destination,\r\n    }) {\r\n        try {\r\n            if (type !== \"nft_transfer\") return null;\r\n\r\n            let r = new RealBadNftTransfer();\r\n            r.type = type;\r\n            r.nftId = nftId;\r\n            r.nftNonce = nftNonce;\r\n            r.destination = destination;\r\n            return r;\r\n        } catch {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check the all fields have correct data types\r\n    isValid() {\r\n        try {\r\n            return (\r\n                this.type === \"nft_transfer\" &&\r\n\r\n                // The NFT nonce is an integer\r\n                Number.isInteger(this.nftNonce) &&\r\n\r\n                // The NFT ID is a 32-byte hex value\r\n                (hexToBytes(this.nftId).length === 32) &&\r\n\r\n                // The destination account is a 32-byte hex value\r\n                (hexToBytes(this.destination).length === 32)\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// Required base fields for every transaction that occurs in the network\r\nexport class RealBadTransaction {\r\n    source = null;          // Source account ID (public key)\r\n    sourceNonce = 0;        // Source account transaction nonce. Used to ensure transactions (including transactionFees) apply IN ORDER.\r\n                            // Must be sequentially incrementing or transaction will be ignored.\r\n                            // nonce is NOT REQURIED and NOT UPDATED if no coins are spent (txFee or transfer).\r\n    timestamp = null;       // Time when the transaction is created. Miners will only propagate and process transactions during a certain time window.\r\n    transactionFee = 0;     // Fee to be paid to the miner if this transaction is accepted into a block. Miners _might_ not accept transactions without fees!\r\n    txData = null;          // The data portion of the transaction. One of the valid transaction object types must go here.\r\n    txId = null;            // Hash of `[source, timestamp, transactionFee, txData]`. This serves as the unique ID for the transaction.\r\n    signature = null;       // Signature of `txId` using the `source` account.\r\n\r\n    // Compute the hash (txId) of this object\r\n    hash() {\r\n        let tx_val = JSON.stringify([\r\n            this.source,\r\n            this.sourceNonce,\r\n            this.timestamp,\r\n            this.transactionFee,\r\n            this.txData,\r\n        ]);\r\n        return bytesToHex(sha256(tx_val));\r\n    }\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        source,\r\n        sourceNonce,\r\n        timestamp,\r\n        transactionFee,\r\n        txData,\r\n        txId,\r\n        signature,\r\n    }) {\r\n        try {\r\n            let r = new RealBadTransaction();\r\n            r.source = source;\r\n            r.sourceNonce = sourceNonce;\r\n            r.timestamp = new Date(timestamp);\r\n            r.transactionFee = transactionFee;\r\n            r.txId = txId;\r\n            r.signature = signature;\r\n\r\n            // Cute!\r\n            r.txData =\r\n                RealBadCoinTransfer.coerce(txData) ||\r\n                RealBadNftMint.coerce(txData) ||\r\n                RealBadNftTransfer.coerce(txData);\r\n\r\n            return r;\r\n        } catch {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check the signature, hash, and confirm that all fields have correct non-null data types\r\n    async isValid() {\r\n        try {\r\n            return (\r\n                // The source ID is a 32-byte hex value\r\n                (hexToBytes(this.source).length === 32) &&\r\n\r\n                // The source nonce is an integer\r\n                Number.isInteger(this.sourceNonce) &&\r\n\r\n                // The timestamp is a Date object and contains a valid value\r\n                (this.timestamp instanceof Date) &&\r\n                !isNaN(this.timestamp.getTime()) &&\r\n\r\n                // The transaction fee is a non-negative finite number\r\n                Number.isFinite(this.transactionFee) &&\r\n                (this.transactionFee >= 0) &&\r\n\r\n                // The transaction internal data is valid\r\n                this.txData.isValid() &&\r\n\r\n                // The hash is a 32-byte hex value and it matches the actual hash of this object\r\n                (hexToBytes(this.txId).length === 32) &&\r\n                (this.hash() === this.txId) &&\r\n\r\n                // The signature is a 64-byte hex value and the signature is a valid sig of the hash from the source\r\n                (hexToBytes(this.signature).length === 64) &&\r\n                await ed.verify(this.signature, this.txId, this.source)\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Seal the transaction, setting the source and timestamp and signing it with the account object provided.\r\n    // The account object needs to provide an `async getPubKeyHex()` and `async sign()` function\r\n    async seal(account) {\r\n        this.source = await account.getPubKeyHex();\r\n        this.timestamp = new Date();\r\n        this.txId = this.hash();\r\n        this.signature = bytesToHex(await account.sign(this.txId));\r\n    }\r\n}\r\n\r\nexport class RealBadBlock {\r\n    prevHash = '00'.repeat(32); // Hash of previous block. It is included in this block to form a block-chain.\r\n    blockHeight = 0;            // How far we are \"above\" the genesis block. This is previous block's height + 1.\r\n    timestamp = null;           // Time of last update to the block (prior to hash computation). This is mainly for display purposes.\r\n    transactions = [];          // List of all transactions in the block\r\n    miningReward = 100;         // Base reward claimed for mining this block\r\n    rewardDestination = null;   // Miner's destination account ID (public key) for mining reward and transaction fees.\r\n    difficulty = 256**2;        // Required difficulty for hash. Increasing this makes it harder to find a valid hash. For example, setting this to 256**N will require the top N bytes of the hash to be zeros.\r\n    nonce = 0;                  // Number that can be changed to cause block's hash to vary\r\n\r\n    // Compute the hash of this object\r\n    // NOTE: We don't STORE the hash of the object inside the object because this\r\n    //       isn't a signed object so we can't trust the validity of any hash that\r\n    //       is TOLD to us! We have to check it ourselves!\r\n    get hash() {\r\n        let block_val = JSON.stringify(this);\r\n        return bytesToHex(sha256(block_val));\r\n    }\r\n\r\n    static difficultyMetric(h) {\r\n        // The difficulty metric is proportional to how low the hash is relative to the \"zero difficulty\" level.\r\n        // The lower the hash as an integer, the bigger the difficulty.\r\n        let zeroDifficulty = 1n << 256n;\r\n        let hashAsInt = hexToBigint(h);\r\n        return zeroDifficulty / hashAsInt;\r\n    }\r\n\r\n    isSealed(minDifficulty = 256**2) {\r\n        let difficulty = Math.max(minDifficulty, this.difficulty);\r\n        let maxHash = (1n << 256n) / BigInt(difficulty);\r\n        let hashAsInt = hexToBigint(this.hash);\r\n        return hashAsInt < maxHash;\r\n    }\r\n\r\n    // Increment the nonce and keep trying to find a hash that is valid.\r\n    // Try up to num_attempts times before giving up.\r\n    tryToSeal(num_attempts) {\r\n        let maxHash = (1n << 256n) / BigInt(this.difficulty);\r\n        this.timestamp = new Date();\r\n\r\n        for (let i = 0; i < num_attempts; i++) {\r\n            let hash = this.hash;\r\n            let hashAsInt = hexToBigint(hash);\r\n            if (hashAsInt < maxHash) {\r\n                return this.isSealed(this.difficulty);\r\n            }\r\n            // We post-increment the nonce, so that repeated calls to this function don't waste any work.\r\n            this.nonce++;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Accept an object and attempt to convert it into an object of this type.\r\n    // Return null if it doesn't work.\r\n    // The resulting object is not guaranteed to be valid!\r\n    static coerce({\r\n        prevHash,\r\n        blockHeight,\r\n        timestamp,\r\n        transactions,\r\n        miningReward,\r\n        rewardDestination,\r\n        difficulty,\r\n        nonce,\r\n    }) {\r\n        try {\r\n            let r = new RealBadBlock();\r\n            r.prevHash = prevHash;\r\n            r.blockHeight = blockHeight;\r\n            r.timestamp = new Date(timestamp);\r\n            r.transactions = transactions.map((t)=>{\r\n                return RealBadTransaction.coerce(t)\r\n            });\r\n            r.miningReward = miningReward;\r\n            r.rewardDestination = rewardDestination;\r\n            r.difficulty = difficulty;\r\n            r.nonce = nonce;\r\n\r\n            return r;\r\n        } catch (error) {\r\n            console.error(error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Check that the block is sealed properly and confirm that all fields have correct non-null data types.\r\n    // This also checks that every Transaction in the block is correctly signed.\r\n    // NOTE: This does NOT mean that the Transactions are ALLOWED and CORRECT. That has to\r\n    //       be validated at the \"block chain\" level!\r\n    async isValid(minDifficulty = 256**2) {\r\n        try {\r\n            return (\r\n                // First check if the block is sealed, which will allow us to skip the work of detailed checks.\r\n                // This helps prevent us from getting spammed by garbage blocks and causing a DoS, since we can\r\n                // quickly check the seal but the seal takes a long time to make!\r\n                this.isSealed(minDifficulty)\r\n                // Note: isSealed() validates the hash quality, after which we don't care about \"difficulty\" or\r\n                //       \"nonce\" so we can skip those fields from now on.\r\n\r\n                // The previous block hash is a 32-byte hex value\r\n                && (hexToBytes(this.prevHash).length === 32)\r\n\r\n                // The blockHeight is a non-negative integer\r\n                && Number.isInteger(this.blockHeight)\r\n                && this.blockHeight >= 0\r\n\r\n                // If the blockHeight is 0, the previous hash should be all 0's as well:\r\n                && (\r\n                    this.blockHeight > 0 ||\r\n                    (this.prevHash === '00'.repeat(32))\r\n                )\r\n\r\n                // The timestamp is a Date object and contains a valid value\r\n                && (this.timestamp instanceof Date)\r\n                && !isNaN(this.timestamp.getTime())\r\n\r\n                // All the transactions have valid signatures and contain correct data types\r\n                && Array.isArray(this.transactions)\r\n                && asyncEvery(this.transactions, async(t)=>{\r\n                    return (t instanceof RealBadTransaction) && await t.isValid();\r\n                })\r\n\r\n                // The mining reward is a non-negative finite number\r\n                && Number.isFinite(this.miningReward)\r\n                && (this.miningReward >= 0)\r\n\r\n                // The reward address is a 32-byte hex value\r\n                && (hexToBytes(this.rewardDestination).length === 32)\r\n            );\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","// This is a background thread that will search for a hash that matches\r\n// the proof-of-work limit\r\nimport * as Comlink from 'comlink';\r\n\r\nimport {\r\n    RealBadBlock\r\n} from './RealBadCoin.tsx';\r\n\r\n\r\nclass MineWorker {\r\n    constructor(block) {\r\n        this._block = RealBadBlock.coerce(block);\r\n    }\r\n\r\n    get nonce() {\r\n        return this._block.nonce;\r\n    }\r\n\r\n    tryToSeal(num_attempts) {\r\n        if (this._block.tryToSeal(num_attempts)) {\r\n            return this._block;\r\n        }\r\n        else return null;\r\n    }\r\n}\r\n\r\nComlink.expose(MineWorker);\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [974], () => (__webpack_require__(2158)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"eeffc38f\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t840: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkrealbadcoin\"] = self[\"webpackChunkrealbadcoin\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(974).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["hexToBigint","hexStr","BigInt","RealBadCoinTransfer","type","destination","amount","r","isValid","this","hexToBytes","length","Number","isFinite","RealBadNftMint","nftData","nftId","hash","bytesToHex","sha256","JSON","stringify","RealBadNftTransfer","nftNonce","isInteger","RealBadTransaction","source","sourceNonce","timestamp","transactionFee","txData","txId","signature","tx_val","Date","coerce","isNaN","getTime","ed","account","getPubKeyHex","sign","RealBadBlock","prevHash","repeat","blockHeight","transactions","miningReward","rewardDestination","difficulty","nonce","block_val","h","isSealed","minDifficulty","Math","max","maxHash","tryToSeal","num_attempts","i","map","t","error","console","Array","isArray","async","arr","predicate","e","asyncEvery","Comlink","constructor","block","_block","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","key","splice","d","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","push","bind","data","moreModules","runtime","pop","next","then"],"sourceRoot":""}